<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - cp2k-omen_cov.info - src/InjectionBeyn.H</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - InjectionBeyn.H<span style="font-size: 80%;"> (source / <a href="InjectionBeyn.H.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">cp2k-omen_cov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">223</td>
            <td class="headerCovTableEntry">479</td>
            <td class="headerCovTableEntryLo">46.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-12-30 22:09:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">50</td>
            <td class="headerCovTableEntryLo">20.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            : Copyright (c) 2017 ETH Zurich
<span class="lineNum">       3 </span>            : Sascha Brueck, Mauro Calderara, Mohammad Hossein Bani-Hashemian, and Mathieu Luisier
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      10 </span>            : */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef __INJECTIONBEYN
<span class="lineNum">      13 </span>            : #define __INJECTIONBEYN
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;omp.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;mpi.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;iostream&gt;
<span class="lineNum">      18 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      19 </span>            : #include &lt;fstream&gt;
<span class="lineNum">      20 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;vector&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;Types.H&quot;
<span class="lineNum">      27 </span>            : #include &quot;Utilities.H&quot;
<span class="lineNum">      28 </span>            : #include &quot;Blas.H&quot;
<span class="lineNum">      29 </span>            : #include &quot;ParallelEig.H&quot;
<span class="lineNum">      30 </span>            : #include &quot;LinearSolver.H&quot;
<span class="lineNum">      31 </span>            : #ifdef HAVE_UMFPACK
<span class="lineNum">      32 </span>            : #include &quot;Umfpack.H&quot;
<span class="lineNum">      33 </span>            : #endif
<span class="lineNum">      34 </span>            : #include &quot;Injection.H&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : /*!  \brief Computes the eigenvalues between two circles around 0 and the corresponding eigenvectors of a polynomial eigenvalue problem
<span class="lineNum">      37 </span>            :  */
<span class="lineNum">      38 </span>            : template&lt;class T&gt;
<span class="lineNum">      39 </span>            : class InjectionBeyn : public Injection&lt;T&gt;{
<span class="lineNum">      40 </span>            : public:
<span class="lineNum">      41 </span>            :     
<span class="lineNum">      42 </span>            :     InjectionBeyn(int,double);
<span class="lineNum">      43 </span>            :     InjectionBeyn(int,double,double,int,int,int);
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :     virtual ~InjectionBeyn();
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :     virtual void initialize(int,int,int);
<span class="lineNum">      48 </span>            :     virtual void calc_kphase(TCSR&lt;T&gt;*,TCSR&lt;T&gt;*,TCSR&lt;CPX&gt;*,int,int,CPX*,CPX*,double*,\
<span class="lineNum">      49 </span>            :                              int*,int*,int*,int*,int,int,int,MPI_Comm,int*);
<span class="lineNum">      50 </span>            :     virtual void calc_kphase_sym(TCSR&lt;T&gt;*,TCSR&lt;T&gt;*,TCSR&lt;CPX&gt;*,int,int,CPX*,CPX*,CPX*,\
<span class="lineNum">      51 </span>            :                                  CPX*,double*,double*,int*,int*,int*,int*,int*,int*,\
<span class="lineNum">      52 </span>            :                                  int*,int*,int,int,MPI_Comm,int*);
<span class="lineNum">      53 </span>            :     virtual void calc_kphase(TCSR&lt;T&gt;*,T*,TCSR&lt;CPX&gt;*,int,int,CPX*,CPX*,double*,int*,\
<span class="lineNum">      54 </span>            :                              int*,int*,int*,int,int,int,MPI_Comm,int*);
<span class="lineNum">      55 </span>            :     virtual void calc_kphase_sym(TCSR&lt;T&gt;*,T*,TCSR&lt;CPX&gt;*,int,int,CPX*,CPX*,CPX*,CPX*,\
<span class="lineNum">      56 </span>            :                                  double*,double*,int*,int*,int*,int*,int*,int*,int*,\
<span class="lineNum">      57 </span>            :                                  int*,int,int,MPI_Comm,int*);
<span class="lineNum">      58 </span>            :     int execute(TCSR&lt;CPX&gt;**,int,int,CPX*,CPX*,int,MPI_Comm);
<span class="lineNum">      59 </span>            :     
<span class="lineNum">      60 </span>            : private:
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :     double mult_factor;
<span class="lineNum">      63 </span>            :     double svd_fac;
<span class="lineNum">      64 </span>            :     double contour_radius;
<span class="lineNum">      65 </span>            :     double imag_limit;
<span class="lineNum">      66 </span>            :     int mpi_size,mpi_rank;
<span class="lineNum">      67 </span>            :     int loc_size,loc_rank;
<span class="lineNum">      68 </span>            :     int NM_input;
<span class="lineNum">      69 </span>            :     int slab_per_bc;
<span class="lineNum">      70 </span>            :     int size_lin_comm;
<span class="lineNum">      71 </span>            :     int NQDR;
<span class="lineNum">      72 </span>            :     int NCRC;
<span class="lineNum">      73 </span>            :     int parallel_svd;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :     void sort_eig(CPX*,CPX*,double*,int*,int*,int*,int*,TCSR&lt;CPX&gt;*,int,int,int);
<span class="lineNum">      76 </span>            :     int get_type(TCSR&lt;CPX&gt;*,CPX*,CPX,double*,int,int);
<span class="lineNum">      77 </span>            :     double calc_derivative(TCSR&lt;CPX&gt;*,CPX*,CPX);
<span class="lineNum">      78 </span>            :     void init_matrix_single(TCSR&lt;CPX&gt;*,TCSR&lt;CPX&gt;*,TCSR&lt;T&gt;*,TCSR&lt;T&gt;*,int,int);
<span class="lineNum">      79 </span>            :     void init_matrix_double(TCSR&lt;CPX&gt;*,TCSR&lt;CPX&gt;*,TCSR&lt;T&gt;*,TCSR&lt;T&gt;*,int,int);
<span class="lineNum">      80 </span>            :     int parallel_decompose(CPX*,CPX*,int,int,MPI_Comm);
<span class="lineNum">      81 </span>            :     int decompose(CPX*,CPX*,int,int);
<span class="lineNum">      82 </span>            :     int svd(CPX*,CPX*,double*,int,int);
<span class="lineNum">      83 </span>            :     int eig(CPX*,int,CPX*);
<span class="lineNum">      84 </span>            :     void allocate_bcast_H(TCSR&lt;CPX&gt;**&amp;,int,MPI_Comm);
<span class="lineNum">      85 </span>            :     void get_Q_matrix_int(CPX*,CPX*,CPX*,TCSR&lt;CPX&gt;**,int,int,int,MPI_Comm);
<span class="lineNum">      86 </span>            :     void get_Q_matrix(CPX*,CPX*,CPX*,TCSR&lt;CPX&gt;**,int,int,int,int,MPI_Comm);
<span class="lineNum">      87 </span>            :     void create_M_matrix(CPX*,TCSR&lt;CPX&gt;**,int,CPX);
<span class="lineNum">      88 </span>            :     void solve_Q_sparse(CPX*,CPX*,int,int,CPX,MPI_Comm);
<span class="lineNum">      89 </span>            :     void solve_Q_full(CPX*,CPX*,int,int,CPX,MPI_Comm);
<span class="lineNum">      90 </span>            :     void inv_Q_full(CPX*,CPX*,int,CPX,MPI_Comm);
<span class="lineNum">      91 </span>            :     void init_Y_matrix(CPX*,int,int);
<span class="lineNum">      92 </span>            : };
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : template&lt;class T&gt;
<span class="lineNum">      95 </span>            : InjectionBeyn&lt;T&gt;::InjectionBeyn(int pslab_per_bc,double pcontour_radius)
<span class="lineNum">      96 </span>            : {
<span class="lineNum">      97 </span>            :     imag_limit     = 5.0e-5; //eps_decay for OMEN part
<span class="lineNum">      98 </span>            :     mult_factor    = 1.2;
<span class="lineNum">      99 </span>            :     svd_fac        = 1.0;
<span class="lineNum">     100 </span>            :     NQDR           = 32;
<span class="lineNum">     101 </span>            :     NCRC           = 2;
<span class="lineNum">     102 </span>            :     size_lin_comm  = 0;
<span class="lineNum">     103 </span>            :     parallel_svd   = 1;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :     slab_per_bc    = pslab_per_bc;
<span class="lineNum">     106 </span>            :     contour_radius = pcontour_radius;
<span class="lineNum">     107 </span>            :     imag_limit     = slab_per_bc*imag_limit;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     MPI_Comm_size(MPI_COMM_WORLD,&amp;mpi_size);
<span class="lineNum">     110 </span>            :     MPI_Comm_rank(MPI_COMM_WORLD,&amp;mpi_rank);
<span class="lineNum">     111 </span>            : }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /************************************************************************************************/
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /*! \brief Constructor
<span class="lineNum">     116 </span>            :  *
<span class="lineNum">     117 </span>            :  *
<span class="lineNum">     118 </span>            :  * \param[in]           pslab_per_bc
<span class="lineNum">     119 </span>            :  *                      Interaction range,
<span class="lineNum">     120 </span>            :  *                      the degree of the polynomial eigenvalue problem is two times this value
<span class="lineNum">     121 </span>            :  *
<span class="lineNum">     122 </span>            :  * \param[in]           pcontour_radius
<span class="lineNum">     123 </span>            :  *                      Radius of the circle around 0
<span class="lineNum">     124 </span>            :  *
<span class="lineNum">     125 </span>            :  * \param[in]           psv
<span class="lineNum">     126 </span>            :  *                      Relative factor to distinguish zero and nonzero singular values,
<span class="lineNum">     127 </span>            :  *
<span class="lineNum">     128 </span>            :  * \param[in]           pNQ
<span class="lineNum">     129 </span>            :  *                      Number of quadrature points per circle
<span class="lineNum">     130 </span>            :  *
<span class="lineNum">     131 </span>            :  * \param[in]           pNC
<span class="lineNum">     132 </span>            :  *                      Number of circles where the LU decomposition is performed.
<span class="lineNum">     133 </span>            :  *                      If equal to two, the inner/outer circle is close to 1 and the outer/inner
<span class="lineNum">     134 </span>            :  *                      circle is the specified radius/the inverse of the specified radius
<span class="lineNum">     135 </span>            :  *                      depending on the sign of injection_sign specified in execute().
<span class="lineNum">     136 </span>            :  *                      If equal to one, only the outer circle with specified radius is computed.
<span class="lineNum">     137 </span>            :  *                      The value at the inner circle with the inverse of the specified radius
<span class="lineNum">     138 </span>            :  *                      is not needed because of symmetry reasons. However, the number of singualar
<span class="lineNum">     139 </span>            :  *                      values and eigenvalues is twice as high, degrading performance.
<span class="lineNum">     140 </span>            :  *  \param[in]          pslc
<span class="lineNum">     141 </span>            :  *                      The number of processors per quadrature point that solve one linear system
<span class="lineNum">     142 </span>            :  *                      The default value of 0 sets this number as small as possible, solving many
<span class="lineNum">     143 </span>            :  *                      different systems in parallel. A higher number may be required if memory
<span class="lineNum">     144 </span>            :  *                      is not sufficient. This might degrade performance.
<a name="145"><span class="lineNum">     145 </span>            :  */</a>
<span class="lineNum">     146 </span>            : template&lt;class T&gt;
<span class="lineNum">     147 </span><span class="lineCov">          4 : InjectionBeyn&lt;T&gt;::InjectionBeyn(int pslab_per_bc,double pcontour_radius,double psv,int pNQ,int pNC,int pslc)</span>
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span>            :     imag_limit     = 5.0e-5; //eps_decay for OMEN part
<span class="lineNum">     150 </span><span class="lineCov">          2 :     mult_factor    = 1.2;</span>
<span class="lineNum">     151 </span><span class="lineCov">          2 :     parallel_svd   = 1;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">          2 :     svd_fac        = psv;</span>
<span class="lineNum">     154 </span><span class="lineCov">          2 :     NQDR           = pNQ;</span>
<span class="lineNum">     155 </span><span class="lineCov">          2 :     NCRC           = pNC;</span>
<span class="lineNum">     156 </span><span class="lineCov">          2 :     size_lin_comm  = pslc;</span>
<span class="lineNum">     157 </span><span class="lineCov">          2 :     slab_per_bc    = pslab_per_bc;</span>
<span class="lineNum">     158 </span><span class="lineCov">          2 :     contour_radius = pcontour_radius;</span>
<span class="lineNum">     159 </span><span class="lineCov">          2 :     imag_limit     = slab_per_bc*imag_limit;</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">          2 :     MPI_Comm_size(MPI_COMM_WORLD,&amp;mpi_size);</span>
<span class="lineNum">     162 </span><span class="lineCov">          2 :     MPI_Comm_rank(MPI_COMM_WORLD,&amp;mpi_rank);</span>
<span class="lineNum">     163 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : /************************************************************************************************/
<a name="166"><span class="lineNum">     166 </span>            : </a>
<span class="lineNum">     167 </span>            : template &lt;class T&gt;
<span class="lineNum">     168 </span><span class="lineCov">          2 : InjectionBeyn&lt;T&gt;::~InjectionBeyn()</span>
<span class="lineNum">     169 </span>            : {
<span class="lineNum">     170 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /************************************************************************************************/
<a name="173"><span class="lineNum">     173 </span>            : </a>
<span class="lineNum">     174 </span>            : template &lt;class T&gt;
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::initialize(int ND,int NP,int NM)</span>
<span class="lineNum">     176 </span>            : {
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     NM_input = min(2*NM,ND/slab_per_bc);</span>
<span class="lineNum">     179 </span>            :  
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /************************************************************************************************/
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : template &lt;class T&gt;
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::sort_eig(CPX *kphase,CPX *Vsurf,double *dEk_dk,int *Ntr,int *ind_Ntr,\</span>
<span class="lineNum">     186 </span>            :                                  int *Nref,int *ind_Nref,TCSR&lt;CPX&gt; *T01,int ND,int NM,int sign)
<span class="lineNum">     187 </span>            : {
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :     int IP,IM;
<span class="lineNum">     190 </span>            :     int type;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     int NR = T01-&gt;size/slab_per_bc;</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     *Ntr   = 0;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     *Nref  = 0;    </span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     for(IM=0;IM&lt;NM;IM++){</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         for (IP=1;IP&lt;slab_per_bc;IP++){</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :             c_zcopy(NR,&amp;Vsurf[IM*ND],1,&amp;Vsurf[IM*ND+IP*NR],1);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :             c_zscal(NR,pow(kphase[IM],-IP),&amp;Vsurf[IM*ND+IP*NR],1);</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         kphase[IM] = CPX(0.0,1.0)*log(pow(kphase[IM],slab_per_bc));</span>
<span class="lineNum">     205 </span>            :           
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         type = get_type(T01,&amp;Vsurf[IM*ND],kphase[IM],&amp;dEk_dk[(*Ntr)],0,sign);</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         if((type&gt;0)&amp;&amp;(dEk_dk[(*Ntr)]&gt;0)){</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             ind_Ntr[(*Ntr)] = IM;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :             (*Ntr)          = (*Ntr)+1;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         }else if (type&lt;0){</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :             ind_Nref[(*Nref)] = IM;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :             (*Nref)           = (*Nref)+1;</span>
<span class="lineNum">     214 </span>            :         }
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : /************************************************************************************************/
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : template &lt;class T&gt;
<span class="lineNum">     221 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::calc_kphase(TCSR&lt;T&gt; *D,TCSR&lt;T&gt; *P,TCSR&lt;CPX&gt; *T01,int ND,int NP,CPX *kphase,\</span>
<span class="lineNum">     222 </span>            :                                     CPX *Vsurf,double *dEk_dk,int *Ntr,int *ind_Ntr,int *Nref, \
<span class="lineNum">     223 </span>            :                                     int *ind_Nref,int sign,int NPROW,int NPCOL,MPI_Comm comm,\
<span class="lineNum">     224 </span>            :                                     int *info)
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :     int IM;
<span class="lineNum">     227 </span>            :     int NR;
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     int NM = NM_input;</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :     int inp_rank;
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     MPI_Comm_rank(comm,&amp;inp_rank);</span>
<span class="lineNum">     232 </span>            :     MPI_Comm loc_comm;
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     MPI_Comm_split(comm,0,sign*inp_rank,&amp;loc_comm);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     MPI_Comm_size(loc_comm,&amp;loc_size);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     MPI_Comm_rank(loc_comm,&amp;loc_rank);</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     if (!loc_rank) NR=D-&gt;size/slab_per_bc;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     MPI_Bcast(&amp;NR,1,MPI_INT,0,loc_comm);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     CPX *YF      = NULL;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     CPX *lambdaR = NULL;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if(!loc_rank){</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         YF      = new CPX[NR*NM];</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         lambdaR = new CPX[NR];</span>
<span class="lineNum">     244 </span>            :     }
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     TCSR&lt;CPX&gt; **H = NULL;</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     double t0 = get_time(0.0);</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if(!loc_rank){</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         TCSR&lt;CPX&gt; *AF = new TCSR&lt;CPX&gt;(D-&gt;size,D-&gt;n_nonzeros,D-&gt;findx);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         TCSR&lt;CPX&gt; *BF = new TCSR&lt;CPX&gt;(D-&gt;size,D-&gt;n_nonzeros,D-&gt;findx);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         if(slab_per_bc==1){</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             init_matrix_single(AF,BF,D,P,ND,NP);</span>
<span class="lineNum">     256 </span>            :         }else{
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             init_matrix_double(AF,BF,D,P,ND,NP);</span>
<span class="lineNum">     258 </span>            :         }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         H = new TCSR&lt;CPX&gt;*[slab_per_bc+1];</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         H[0] = new TCSR&lt;CPX&gt;(NR,BF-&gt;n_nonzeros,BF-&gt;findx);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         H[0]-&gt;n_nonzeros=0;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         init_var(H[0]-&gt;index_i,NR);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         for(int iter=1;iter&lt;=slab_per_bc;iter++){</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :             H[iter] = new TCSR&lt;CPX&gt;(NR,AF-&gt;n_nonzeros,AF-&gt;findx);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             H[iter]-&gt;n_nonzeros=0;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :             init_var(H[iter]-&gt;index_i,NR);</span>
<span class="lineNum">     268 </span>            :         }
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         for(int IR=0;IR&lt;NR;IR++){</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :             for(int IC=BF-&gt;edge_i[IR]-BF-&gt;findx;IC&lt;BF-&gt;edge_i[IR+1]-BF-&gt;findx;IC++){</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                 H[0]-&gt;index_i[IR]++;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 H[0]-&gt;index_j[H[0]-&gt;n_nonzeros]=BF-&gt;index_j[IC]-BF-&gt;findx+H[0]-&gt;findx;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                 H[0]-&gt;nnz[H[0]-&gt;n_nonzeros++]=-BF-&gt;nnz[IC];</span>
<span class="lineNum">     274 </span>            :             }
<span class="lineNum">     275 </span>            :         }
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         for(int IR=0;IR&lt;NR;IR++){</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :             for(int IC=AF-&gt;edge_i[IR]-AF-&gt;findx;IC&lt;AF-&gt;edge_i[IR+1]-AF-&gt;findx;IC++){</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                 int col_ind = AF-&gt;index_j[IC]-AF-&gt;findx;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :                 int mat_ind = col_ind/NR+1;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                 H[mat_ind]-&gt;index_i[IR]++;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                 H[mat_ind]-&gt;index_j[H[mat_ind]-&gt;n_nonzeros]=col_ind%NR+H[mat_ind]-&gt;findx;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 H[mat_ind]-&gt;nnz[H[mat_ind]-&gt;n_nonzeros++]=AF-&gt;nnz[IC];</span>
<span class="lineNum">     283 </span>            :             }
<span class="lineNum">     284 </span>            :         }
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         for(int iter=0;iter&lt;=slab_per_bc;iter++){</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :             H[iter]-&gt;get_row_edge();</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :             H[iter]-&gt;get_diag_pos();</span>
<span class="lineNum">     288 </span>            :         }
<span class="lineNum">     289 </span>            :  
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         delete AF;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         delete BF;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     if(!mpi_rank) printf(&quot;Time to generate matrices: %e\n&quot;,get_time(t0));</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     NM=execute(H,NR,NM,lambdaR,YF,sign,loc_comm);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     t0 = get_time(0.0);</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     if(!loc_rank){</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         int *reord_index = new int[NM];</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         sort_abs_vec(lambdaR,reord_index,NM);</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         for(IM=0;IM&lt;NM;IM++){</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :             c_zcopy(NR,&amp;YF[IM*NR],1,&amp;Vsurf[reord_index[IM]*ND],1);</span>
<span class="lineNum">     309 </span>            :         }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         c_zcopy(NM,lambdaR,1,kphase,1);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         delete[] reord_index;</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         sort_eig(kphase,Vsurf,dEk_dk,Ntr,ind_Ntr,Nref,ind_Nref,T01,ND,NM,sign);</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if(!mpi_rank) printf(&quot;Sort time: %e\n&quot;,get_time(t0));</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     if (!loc_rank){</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         delete[] YF;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         delete[] lambdaR;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         for(int IP=0;IP&lt;slab_per_bc+1;IP++){</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :             delete H[IP];</span>
<span class="lineNum">     325 </span>            :         }
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         delete[] H;</span>
<span class="lineNum">     327 </span>            :     }
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     MPI_Comm_free(&amp;loc_comm);</span>
<span class="lineNum">     329 </span>            :  
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : /************************************************************************************************/
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : /*! \brief Main routine of Beyn solver
<span class="lineNum">     335 </span>            :  *
<span class="lineNum">     336 </span>            :  *
<span class="lineNum">     337 </span>            :  * \param[in]           **A
<span class="lineNum">     338 </span>            :  *                      Pointer to 2*slab_per_bc+1 sparse matrices holding the coefficient
<span class="lineNum">     339 </span>            :  *                      matrices of the polynomial eigenvalue problem
<span class="lineNum">     340 </span>            :  *
<span class="lineNum">     341 </span>            :  * \param[in]           NR
<span class="lineNum">     342 </span>            :  *                      Size of the matrices
<span class="lineNum">     343 </span>            :  *
<span class="lineNum">     344 </span>            :  * \param[in]           NM
<span class="lineNum">     345 </span>            :  *                      Number of test vectors, an estimate for the number of eigenvalues
<span class="lineNum">     346 </span>            :  *                      inside the contour
<span class="lineNum">     347 </span>            :  *
<span class="lineNum">     348 </span>            :  * \param[out]          *lambdaR
<span class="lineNum">     349 </span>            :  *                      Pointer to the eigenvalues, must be size NM
<span class="lineNum">     350 </span>            :  *                   
<span class="lineNum">     351 </span>            :  * \param[out]          *YF
<span class="lineNum">     352 </span>            :  *                      Pointer to the eigenvectors, must be size NR*NM
<span class="lineNum">     353 </span>            :  *
<span class="lineNum">     354 </span>            :  * \param[in]           sign
<span class="lineNum">     355 </span>            :  *                      Injection sign, determines if modes decaying to left or right are wanted
<span class="lineNum">     356 </span>            :  *
<span class="lineNum">     357 </span>            :  * \param[in]           comm
<span class="lineNum">     358 </span>            :  *                      MPI Communicator
<span class="lineNum">     359 </span>            :  */
<span class="lineNum">     360 </span>            : template &lt;class T&gt;
<span class="lineNum">     361 </span><span class="lineCov">          2 : int InjectionBeyn&lt;T&gt;::execute(TCSR&lt;CPX&gt; **A,int NR,int NM,CPX *lambdaR,CPX *YF, \</span>
<span class="lineNum">     362 </span>            :                                int sign,MPI_Comm comm)
<span class="lineNum">     363 </span>            : {
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :     int IP,IM;
<span class="lineNum">     366 </span>            :     double LBound,UBound;
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">          2 :     MPI_Comm_size(comm,&amp;loc_size);</span>
<span class="lineNum">     369 </span><span class="lineCov">          2 :     MPI_Comm_rank(comm,&amp;loc_rank);</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineCov">          2 :     if(sign&gt;0){</span>
<span class="lineNum">     372 </span><span class="lineCov">          1 :         UBound = 1.0+1.0/contour_radius;</span>
<span class="lineNum">     373 </span><span class="lineCov">          1 :         LBound = 1.0/contour_radius;</span>
<span class="lineNum">     374 </span>            :     }else{
<span class="lineNum">     375 </span><span class="lineCov">          1 :         UBound = contour_radius;</span>
<span class="lineNum">     376 </span><span class="lineCov">          1 :         LBound = 1.0/(1.0+1.0/contour_radius);</span>
<span class="lineNum">     377 </span>            :     }
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">          2 :     CPX *QF1 = NULL;</span>
<span class="lineNum">     380 </span><span class="lineCov">          2 :     CPX *QF2 = NULL;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     383 </span><span class="lineCov">          2 :         init_Y_matrix(YF,NM,NR);</span>
<span class="lineNum">     384 </span><span class="lineCov">      10370 :         QF1 = new CPX[NR*NM];</span>
<span class="lineNum">     385 </span><span class="lineCov">      10370 :         QF2 = new CPX[NR*NM];</span>
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">          2 :     double t0 = get_time(0.0);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineCov">          2 :     get_Q_matrix_int(QF1,QF2,YF,A,sign,NR,NM,comm);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineCov">          2 :     if(!mpi_rank) printf(&quot;Time to generate Q: %e\n&quot;,get_time(t0));</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">          2 :     t0 = get_time(0.0);</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">          2 :     if(parallel_svd){</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineCov">          2 :         NM=parallel_decompose(QF1,QF2,NR,NM,comm);</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     }else if(!loc_rank){</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         NM=decompose(QF1,QF2,NR,NM);</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :     }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">          2 :     if(!mpi_rank) printf(&quot;Time for SVD: %e\n&quot;,get_time(t0));</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">          2 :     t0 = get_time(0.0);</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     411 </span>            :     
<span class="lineNum">     412 </span><span class="lineCov">          2 :         if(NM==NR) printf(&quot;Too many eigenvalues found.\n&quot;);</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">          2 :         eig(QF2,NM,lambdaR);</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">          6 :         c_zgemm('N','N',NR,NM,NM,CPX(1.0,0.0),QF1,NR,QF2,NM,CPX(0.0,0.0),YF,NR);</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">          2 :         IP = 0;</span>
<span class="lineNum">     419 </span><span class="lineCov">         72 :         for(IM=0;IM&lt;NM;IM++){</span>
<span class="lineNum">     420 </span><span class="lineCov">        200 :             if((abs(lambdaR[IM])&gt;=LBound)&amp;&amp;(abs(lambdaR[IM])&lt;=UBound)){</span>
<span class="lineNum">     421 </span><span class="lineCov">         50 :                 if(IP&lt;IM){</span>
<span class="lineNum">     422 </span><span class="lineCov">         50 :                     c_zcopy(NR,&amp;YF[IM*NR],1,&amp;YF[IP*NR],1);</span>
<span class="lineNum">     423 </span><span class="lineCov">         25 :                     lambdaR[IP]=lambdaR[IM];</span>
<span class="lineNum">     424 </span>            :                 }
<span class="lineNum">     425 </span><span class="lineCov">         50 :                 IP++;</span>
<span class="lineNum">     426 </span>            :             }
<span class="lineNum">     427 </span>            :         }
<span class="lineNum">     428 </span>            :         NM=IP;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">          2 :     if(!mpi_rank) printf(&quot;Sequential time: %e\n&quot;,get_time(t0));</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     435 </span><span class="lineCov">          2 :         delete[] QF1;</span>
<span class="lineNum">     436 </span><span class="lineCov">          2 :         delete[] QF2;</span>
<span class="lineNum">     437 </span>            :     }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineCov">          2 :     return NM;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : }
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            : /************************************************************************************************/
<a name="444"><span class="lineNum">     444 </span>            : </a>
<span class="lineNum">     445 </span>            : template &lt;class T&gt;
<span class="lineNum">     446 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::calc_kphase_sym(TCSR&lt;T&gt; *D,TCSR&lt;T&gt; *P,TCSR&lt;CPX&gt; *T01,int ND,int NP,\</span>
<span class="lineNum">     447 </span>            :                                         CPX *kphasel,CPX *kphaser,CPX *Vsurfl,CPX *Vsurfr, \
<span class="lineNum">     448 </span>            :                                         double *dEkl_dk, double *dEkr_dk, int *Ntrl, int *Ntrr, \
<span class="lineNum">     449 </span>            :                                         int *ind_Ntrl,int *ind_Ntrr,int *Nrefl,int *Nrefr, \
<span class="lineNum">     450 </span>            :                                         int *ind_Nrefl,int *ind_Nrefr,int NPROW,int NPCOL, \
<span class="lineNum">     451 </span>            :                                         MPI_Comm comm,int *info)
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span>            :   /*
<span class="lineNum">     454 </span>            :  
<span class="lineNum">     455 </span>            :     
<span class="lineNum">     456 </span>            :     sort_eig(kphasel,Vsurfl,dEkl_dk,Ntrl,ind_Ntrl,Nrefl,ind_Nrefl,phase,VUp,VDown,T01,ND,NP,1);
<span class="lineNum">     457 </span>            :     sort_eig(kphaser,Vsurfr,dEkr_dk,Ntrr,ind_Ntrr,Nrefr,ind_Nrefr,phase,VUp,VDown,T01,ND,NP,-1);
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   */
<span class="lineNum">     461 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : /************************************************************************************************/
<a name="464"><span class="lineNum">     464 </span>            : </a>
<span class="lineNum">     465 </span>            : template &lt;class T&gt;
<span class="lineNum">     466 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::calc_kphase(TCSR&lt;T&gt; *D,T *P,TCSR&lt;CPX&gt; *T01,int ND,int NP,CPX *kphase,\</span>
<span class="lineNum">     467 </span>            :                                     CPX *Vsurf,double *dEk_dk,int *Ntr,int *ind_Ntr,int *Nref, \
<span class="lineNum">     468 </span>            :                                     int *ind_Nref,int sign,int NPROW,int NPCOL,MPI_Comm comm,\
<span class="lineNum">     469 </span>            :                                     int *info)
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : /************************************************************************************************/
<a name="474"><span class="lineNum">     474 </span>            : </a>
<span class="lineNum">     475 </span>            : template &lt;class T&gt;
<span class="lineNum">     476 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::calc_kphase_sym(TCSR&lt;T&gt; *D,T *P,TCSR&lt;CPX&gt; *T01,int ND,int NP,\</span>
<span class="lineNum">     477 </span>            :                                         CPX *kphasel,CPX *kphaser,CPX *Vsurfl,CPX *Vsurfr, \
<span class="lineNum">     478 </span>            :                                         double *dEkl_dk, double *dEkr_dk, int *Ntrl, int *Ntrr, \
<span class="lineNum">     479 </span>            :                                         int *ind_Ntrl,int *ind_Ntrr,int *Nrefl,int *Nrefr, \
<span class="lineNum">     480 </span>            :                                         int *ind_Nrefl,int *ind_Nrefr,int NPROW,int NPCOL, \
<span class="lineNum">     481 </span>            :                                         MPI_Comm comm,int *info)
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /************************************************************************************************/
<a name="486"><span class="lineNum">     486 </span>            : </a>
<span class="lineNum">     487 </span>            : template &lt;class T&gt;
<span class="lineNum">     488 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::allocate_bcast_H(TCSR&lt;CPX&gt; **&amp;H,int source,MPI_Comm comm)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span>            :     int bcast_rank;
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     MPI_Comm_rank(comm,&amp;bcast_rank);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     int *nonzH = new int[slab_per_bc+1];</span>
<span class="lineNum">     493 </span>            :     int findxH;
<span class="lineNum">     494 </span>            :     int sizeH;
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     if(!bcast_rank){</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         for (int ibw=0;ibw&lt;slab_per_bc+1;ibw++) {</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :             nonzH[ibw] = H[ibw]-&gt;n_nonzeros;</span>
<span class="lineNum">     498 </span>            :         }
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         findxH = H[0]-&gt;findx;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         sizeH  = H[0]-&gt;size;</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     MPI_Bcast(nonzH,slab_per_bc+1,MPI_INT,source,comm);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     MPI_Bcast(&amp;findxH,1,MPI_INT,source,comm);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     MPI_Bcast(&amp;sizeH,1,MPI_INT,source,comm);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     if(bcast_rank){</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :         H = new TCSR&lt;CPX&gt;*[slab_per_bc+1];</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         for(int ibw=0;ibw&lt;slab_per_bc+1;ibw++){</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :             H[ibw] = new TCSR&lt;CPX&gt;(sizeH,nonzH[ibw],findxH);</span>
<span class="lineNum">     509 </span>            :         }
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     delete[] nonzH;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     for(int ibw=0;ibw&lt;slab_per_bc+1;ibw++){</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         TCSR&lt;CPX&gt; *M=H[ibw];</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         MPI_Bcast(&amp;M-&gt;size,1,MPI_INT,source,comm);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         MPI_Bcast(&amp;M-&gt;n_nonzeros,1,MPI_INT,source,comm);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         MPI_Bcast(M-&gt;index_i,M-&gt;size,MPI_INT,source,comm);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         MPI_Bcast(M-&gt;edge_i,M-&gt;size+1,MPI_INT,source,comm);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         MPI_Bcast(M-&gt;index_j,M-&gt;n_nonzeros,MPI_INT,source,comm);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         MPI_Bcast(M-&gt;diag_pos,M-&gt;size,MPI_INT,source,comm);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         MPI_Bcast(M-&gt;nnz,M-&gt;n_nonzeros,MPI_DOUBLE_COMPLEX,source,comm);</span>
<span class="lineNum">     521 </span>            :     }
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : /************************************************************************************************/
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : template &lt;class T&gt;
<span class="lineNum">     527 </span><span class="lineCov">          2 : void InjectionBeyn&lt;T&gt;::get_Q_matrix(CPX *Q,CPX *Q2,CPX *Y,TCSR&lt;CPX&gt; **A,int sign,int NR,int NM,\</span>
<span class="lineNum">     528 </span>            :                                      int NPOC,MPI_Comm comm)
<span class="lineNum">     529 </span>            : {
<span class="lineNum">     530 </span><span class="lineCov">          2 :     if(slab_per_bc==1) NCRC=2;</span>
<span class="lineNum">     531 </span><span class="lineCov">          4 :     if(size_lin_comm&lt;=0 || size_lin_comm&gt;loc_size) size_lin_comm=max(1,loc_size/(NCRC*NPOC));</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :     double R_in,R_out;
<span class="lineNum">     534 </span><span class="lineCov">          2 :     R_out = mult_factor*contour_radius;</span>
<span class="lineNum">     535 </span><span class="lineCov">          2 :     if(NCRC==2){</span>
<span class="lineNum">     536 </span><span class="lineCov">          2 :         if(sign&gt;0){</span>
<span class="lineNum">     537 </span><span class="lineCov">          1 :             R_out = 1.0+mult_factor/contour_radius;</span>
<span class="lineNum">     538 </span><span class="lineCov">          1 :             R_in  = 1.0/(mult_factor*contour_radius);</span>
<span class="lineNum">     539 </span>            :         }else{
<span class="lineNum">     540 </span><span class="lineCov">          1 :             R_out = mult_factor*contour_radius;</span>
<span class="lineNum">     541 </span><span class="lineCov">          1 :             R_in  = 1.0/(1.0+mult_factor/contour_radius);</span>
<span class="lineNum">     542 </span>            :         }
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :     MPI_Comm lin_comm;
<span class="lineNum">     546 </span><span class="lineCov">          2 :     int point_index_in_iter = loc_rank/size_lin_comm;</span>
<span class="lineNum">     547 </span><span class="lineCov">          2 :     MPI_Comm_split(comm,point_index_in_iter,loc_rank,&amp;lin_comm);</span>
<span class="lineNum">     548 </span>            :     int rank_lin_comm;
<span class="lineNum">     549 </span><span class="lineCov">          2 :     MPI_Comm_rank(lin_comm,&amp;rank_lin_comm);</span>
<span class="lineNum">     550 </span>            :     MPI_Comm master_comm;
<span class="lineNum">     551 </span><span class="lineCov">          2 :     int points_per_iter = loc_size/size_lin_comm;</span>
<span class="lineNum">     552 </span><span class="lineCov">          2 :     int color = rank_lin_comm;</span>
<span class="lineNum">     553 </span><span class="lineCov">          2 :     if (loc_rank&gt;=points_per_iter*size_lin_comm) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         color = MPI_UNDEFINED;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         rank_lin_comm = -1;</span>
<span class="lineNum">     556 </span>            :     }
<span class="lineNum">     557 </span><span class="lineCov">          2 :     MPI_Comm_split(comm,color,loc_rank,&amp;master_comm);</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineCov">          2 :     if(!rank_lin_comm &amp;&amp; loc_size&gt;1){</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         allocate_bcast_H(A,0,master_comm);</span>
<span class="lineNum">     561 </span>            :     }
<span class="lineNum">     562 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     563 </span><span class="lineCov">          2 :         init_var(Q ,NR*NM);</span>
<span class="lineNum">     564 </span>            :         init_var(Q2,NR*NM);
<span class="lineNum">     565 </span>            :     }
<span class="lineNum">     566 </span><span class="lineCov">          2 :     CPX *QLoc  = NULL;</span>
<span class="lineNum">     567 </span><span class="lineCov">          2 :     CPX *QLoc2 = NULL;</span>
<span class="lineNum">     568 </span><span class="lineCov">          2 :     if(!rank_lin_comm){</span>
<span class="lineNum">     569 </span><span class="lineCov">      10370 :         QLoc  = new CPX[NR*NR];</span>
<span class="lineNum">     570 </span><span class="lineCov">      10370 :         QLoc2 = new CPX[NR*NM];</span>
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :     int IP;
<span class="lineNum">     574 </span><span class="lineCov">         66 :     for(IP=0;IP&lt;ceil(double(NCRC*NPOC)/double(points_per_iter));IP++){</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineCov">         64 :         int IR = IP*points_per_iter+point_index_in_iter;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">         64 :         if(!loc_rank){</span>
<span class="lineNum">     579 </span><span class="lineCov">         64 :             c_zcopy(NM*NR,Y,1,QLoc2,1);</span>
<span class="lineNum">     580 </span>            :         }
<span class="lineNum">     581 </span><span class="lineCov">         64 :         if(!rank_lin_comm &amp;&amp; loc_size&gt;1){</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :             MPI_Bcast(QLoc2,NM*NR,MPI_DOUBLE_COMPLEX,0,master_comm);</span>
<span class="lineNum">     583 </span>            :         }
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineCov">         64 :         CPX z;</span>
<span class="lineNum">     586 </span><span class="lineCov">         64 :         if(IR&lt;NPOC){</span>
<span class="lineNum">     587 </span><span class="lineCov">        128 :             z = R_out*exp(CPX(0.0,2.0*(IR+0.5)*M_PI/NQDR));</span>
<span class="lineNum">     588 </span><span class="lineCov">         32 :         }else if(IR&gt;=NPOC &amp;&amp; IR&lt;NCRC*NPOC){</span>
<span class="lineNum">     589 </span><span class="lineCov">        128 :             z = R_in*exp(CPX(0.0,2.0*((IR-NPOC)+0.5)*M_PI/NQDR));</span>
<span class="lineNum">     590 </span>            :         }
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">         64 :         if(!rank_lin_comm &amp;&amp; IR&lt;NCRC*NPOC){</span>
<span class="lineNum">     593 </span><span class="lineCov">         64 :             create_M_matrix(QLoc,A,NR,z);</span>
<span class="lineNum">     594 </span>            :         }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineCov">         64 :         if(rank_lin_comm&gt;=0 &amp;&amp; IR&lt;NCRC*NPOC){</span>
<span class="lineNum">     597 </span><span class="lineCov">         64 :             if(slab_per_bc==1){</span>
<span class="lineNum">     598 </span>            :                 solve_Q_sparse(QLoc,QLoc2,NR,NM,z,lin_comm);
<span class="lineNum">     599 </span><span class="lineCov">         64 :             }else if(NR==NM){</span>
<span class="lineNum">     600 </span><span class="lineCov">         64 :                 inv_Q_full(QLoc,QLoc2,NM,z,lin_comm);</span>
<span class="lineNum">     601 </span>            :             }else{
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                 solve_Q_full(QLoc,QLoc2,NR,NM,z,lin_comm);</span>
<span class="lineNum">     603 </span>            :             }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         }else if(!rank_lin_comm){</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :             init_var(QLoc ,NR*NM);</span>
<span class="lineNum">     606 </span>            :             init_var(QLoc2,NR*NM);
<span class="lineNum">     607 </span>            :         }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineCov">         64 :         if(!rank_lin_comm &amp;&amp; loc_size&gt;1){</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             MPI_Allreduce(MPI_IN_PLACE,QLoc ,NR*NM,MPI_DOUBLE_COMPLEX,MPI_SUM,master_comm);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :             MPI_Allreduce(MPI_IN_PLACE,QLoc2,NR*NM,MPI_DOUBLE_COMPLEX,MPI_SUM,master_comm);</span>
<span class="lineNum">     612 </span>            :         }
<span class="lineNum">     613 </span><span class="lineCov">         64 :         if(!loc_rank){</span>
<span class="lineNum">     614 </span><span class="lineCov">        128 :             c_zaxpy(NR*NM,CPX(1.0,0.0),QLoc ,1,Q ,1);</span>
<span class="lineNum">     615 </span><span class="lineCov">        128 :             c_zaxpy(NR*NM,CPX(1.0,0.0),QLoc2,1,Q2,1);</span>
<span class="lineNum">     616 </span>            :         }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :     }
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">          2 :     if(!rank_lin_comm){</span>
<span class="lineNum">     621 </span><span class="lineCov">          2 :         delete[] QLoc;</span>
<span class="lineNum">     622 </span><span class="lineCov">          2 :         delete[] QLoc2;</span>
<span class="lineNum">     623 </span><span class="lineCov">          2 :         if(loc_rank){</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :             for(IP=0;IP&lt;slab_per_bc+1;IP++){</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                 delete A[IP];</span>
<span class="lineNum">     626 </span>            :             }
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :             delete[] A;</span>
<span class="lineNum">     628 </span>            :         }
<span class="lineNum">     629 </span>            :     }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">          2 :     MPI_Comm_free(&amp;lin_comm);</span>
<span class="lineNum">     632 </span><span class="lineCov">          2 :     if (master_comm!=MPI_COMM_NULL) {</span>
<span class="lineNum">     633 </span><span class="lineCov">          2 :         MPI_Comm_free(&amp;master_comm);</span>
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            : /************************************************************************************************/
<a name="639"><span class="lineNum">     639 </span>            : </a>
<span class="lineNum">     640 </span>            : template &lt;&gt;
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;CPX&gt;::get_Q_matrix_int(CPX *Q,CPX *Q2,CPX *Y,TCSR&lt;CPX&gt; **A,int sign,\</span>
<span class="lineNum">     642 </span>            :                                            int NR,int NM,MPI_Comm comm)
<span class="lineNum">     643 </span>            : {
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     get_Q_matrix(Q,Q2,Y,A,sign,NR,NM,NQDR,comm);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            : /************************************************************************************************/
<a name="650"><span class="lineNum">     650 </span>            : </a>
<span class="lineNum">     651 </span>            : template &lt;&gt;
<span class="lineNum">     652 </span><span class="lineCov">          2 : void InjectionBeyn&lt;double&gt;::get_Q_matrix_int(CPX *Q,CPX *Q2,CPX *Y,TCSR&lt;CPX&gt; **A,int sign,\</span>
<span class="lineNum">     653 </span>            :                                               int NR,int NM,MPI_Comm comm)
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     657 </span><span class="lineCov">          2 :         c_dscal(NR*NM,0.0,((double*)Y)+1,2);</span>
<span class="lineNum">     658 </span>            :     }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">          2 :     get_Q_matrix(Q,Q2,Y,A,sign,NR,NM,NQDR/2,comm);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">          2 :     if(!loc_rank){</span>
<span class="lineNum">     663 </span><span class="lineCov">          4 :         c_dscal(NR*NM,2.0, (double*)Q    ,2);</span>
<span class="lineNum">     664 </span><span class="lineCov">          4 :         c_dscal(NR*NM,0.0,((double*)Q )+1,2);</span>
<span class="lineNum">     665 </span><span class="lineCov">          2 :         c_dscal(NR*NM,2.0, (double*)Q2   ,2);</span>
<span class="lineNum">     666 </span><span class="lineCov">          2 :         c_dscal(NR*NM,0.0,((double*)Q2)+1,2);</span>
<span class="lineNum">     667 </span>            :     }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : /************************************************************************************************/
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : template &lt;class T&gt;
<span class="lineNum">     674 </span><span class="lineCov">         64 : void InjectionBeyn&lt;T&gt;::create_M_matrix(CPX *M,TCSR&lt;CPX&gt; **A,int NR,CPX z)</span>
<span class="lineNum">     675 </span>            : {
<span class="lineNum">     676 </span><span class="lineCov">         64 :     init_var(M,NR*NR);</span>
<span class="lineNum">     677 </span>            :  
<span class="lineNum">     678 </span><span class="lineCov">        960 :     for(int IP=0;IP&lt;slab_per_bc+1;IP++){</span>
<span class="lineNum">     679 </span><span class="lineCov">        448 :         TCSR&lt;CPX&gt;* AA = A[IP];</span>
<span class="lineNum">     680 </span><span class="lineCov">        448 :         int ffindx = AA-&gt;findx;</span>
<span class="lineNum">     681 </span><span class="lineCov">        448 :         CPX zz = pow(z,slab_per_bc/2-IP);</span>
<span class="lineNum">     682 </span><span class="lineCov">      32704 :         for(int IR=0;IR&lt;NR;IR++){</span>
<span class="lineNum">     683 </span><span class="lineCov">    1117696 :             for(int IJ=AA-&gt;edge_i[IR]-ffindx;IJ&lt;AA-&gt;edge_i[IR+1]-ffindx;IJ++){</span>
<span class="lineNum">     684 </span><span class="lineCov">    3256320 :                 M[IR+(AA-&gt;index_j[IJ]-ffindx)*NR] += zz*AA-&gt;nnz[IJ];</span>
<span class="lineNum">     685 </span>            :             }
<span class="lineNum">     686 </span>            :         }
<span class="lineNum">     687 </span>            :     }
<span class="lineNum">     688 </span><span class="lineCov">         64 : }</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /************************************************************************************************/
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : template &lt;class T&gt;
<span class="lineNum">     693 </span>            : void InjectionBeyn&lt;T&gt;::solve_Q_sparse(CPX *QM,CPX *QY,int NR,int NM,CPX z,MPI_Comm lin_comm)
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span>            : #ifdef HAVE_UMFPACK
<span class="lineNum">     696 </span>            :     int lin_size,lin_rank;
<span class="lineNum">     697 </span>            :     MPI_Comm_size(lin_comm,&amp;lin_size);
<span class="lineNum">     698 </span>            :     MPI_Comm_rank(lin_comm,&amp;lin_rank);
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     if(!lin_rank){
<span class="lineNum">     701 </span>            :  
<span class="lineNum">     702 </span>            :         TCSR&lt;CPX&gt; *M_sp = new TCSR&lt;CPX&gt;(NR,NR*NR,1);
<span class="lineNum">     703 </span>            :         M_sp-&gt;full_to_sparse(QM,NR,NR);
<span class="lineNum">     704 </span>            :  
<span class="lineNum">     705 </span>            :         LinearSolver&lt;CPX&gt; *M_solver = new Umfpack&lt;CPX&gt;(M_sp,MPI_COMM_SELF);
<span class="lineNum">     706 </span>            :         M_solver-&gt;prepare();
<span class="lineNum">     707 </span>            :         M_solver-&gt;solve_equation(QM,QY,NM);
<span class="lineNum">     708 </span>            :  
<span class="lineNum">     709 </span>            :         delete M_solver;
<span class="lineNum">     710 </span>            :         delete M_sp;
<span class="lineNum">     711 </span>            :  
<span class="lineNum">     712 </span>            :         if(abs(z)&lt;1.0) c_zscal(NR*NM,-1.0,QM,1);
<span class="lineNum">     713 </span>            :         c_zcopy(NR*NM,QM,1,QY,1);
<span class="lineNum">     714 </span>            :         c_zscal(NR*NM,z,QY,1);
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :     }
<span class="lineNum">     717 </span>            : #endif
<span class="lineNum">     718 </span>            : }
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            : /************************************************************************************************/
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            : template &lt;class T&gt;
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::solve_Q_full(CPX *QM,CPX *QY,int NR,int NM,CPX z,MPI_Comm lin_comm)</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span>            :     int lin_size,lin_rank;
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     MPI_Comm_size(lin_comm,&amp;lin_size);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     MPI_Comm_rank(lin_comm,&amp;lin_rank);</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     if(NCRC==1){</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         p_lin(QM,QY,NR,NM,z,lin_comm);</span>
<span class="lineNum">     731 </span>            :     }else{
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         if(lin_size==1){</span>
<span class="lineNum">     733 </span>            :             int info;
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :             int *ipiv = new int[NR];</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             c_zgetrf(NR,NR,QM,NR,ipiv,&amp;info);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :             c_zgetrs('N',NR,NM,QM,NR,ipiv,QY,NR,&amp;info);</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :             delete[] ipiv;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :             c_zcopy(NR*NM,QY,1,QM,1);</span>
<span class="lineNum">     739 </span>            :         }else{
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             p_lin(QM,QY,QM,NR,NM,lin_comm);</span>
<span class="lineNum">     741 </span>            :         }
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         if(!lin_rank){</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :             if(abs(z)&lt;1.0) c_zscal(NR*NM,-1.0,QM,1);</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :             c_zcopy(NR*NM,QM,1,QY,1);</span>
<span class="lineNum">     745 </span>            :             c_zscal(NR*NM,z,QY,1);
<span class="lineNum">     746 </span>            :         }
<span class="lineNum">     747 </span>            :     }
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : /************************************************************************************************/
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : template &lt;class T&gt;
<span class="lineNum">     754 </span><span class="lineCov">         64 : void InjectionBeyn&lt;T&gt;::inv_Q_full(CPX *QM,CPX *QY,int NR,CPX z,MPI_Comm lin_comm)</span>
<span class="lineNum">     755 </span>            : {
<span class="lineNum">     756 </span>            :     int lin_size,lin_rank;
<span class="lineNum">     757 </span><span class="lineCov">         64 :     MPI_Comm_size(lin_comm,&amp;lin_size);</span>
<span class="lineNum">     758 </span><span class="lineCov">         64 :     MPI_Comm_rank(lin_comm,&amp;lin_rank);</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">         64 :     if(NCRC==1){</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         p_inv(QM,QY,NR,z,lin_comm);</span>
<span class="lineNum">     762 </span>            :     }else{
<span class="lineNum">     763 </span><span class="lineCov">         64 :         if(lin_size==1){</span>
<span class="lineNum">     764 </span>            :             int info;
<span class="lineNum">     765 </span><span class="lineCov">         64 :             int *ipiv = new int[NR];</span>
<span class="lineNum">     766 </span><span class="lineCov">         64 :             c_zgetrf(NR,NR,QM,NR,ipiv,&amp;info);</span>
<span class="lineNum">     767 </span><span class="lineCov">         64 :             c_zgetri(NR,QM,NR,ipiv,QY,-1,&amp;info);</span>
<span class="lineNum">     768 </span><span class="lineCov">        192 :             int lwork=min(int(real(QY[0])),NR*NR);</span>
<span class="lineNum">     769 </span><span class="lineCov">         64 :             c_zgetri(NR,QM,NR,ipiv,QY,lwork,&amp;info);</span>
<span class="lineNum">     770 </span><span class="lineCov">         64 :             delete[] ipiv;</span>
<span class="lineNum">     771 </span>            :         }else{
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :             p_inv(QM,NR,lin_comm);</span>
<span class="lineNum">     773 </span>            :         }
<span class="lineNum">     774 </span><span class="lineCov">         64 :         if(!lin_rank){</span>
<span class="lineNum">     775 </span><span class="lineCov">        128 :             if(abs(z)&lt;1.0) c_zscal(NR*NR,-1.0,QM,1);</span>
<span class="lineNum">     776 </span><span class="lineCov">        128 :             c_zcopy(NR*NR,QM,1,QY,1);</span>
<span class="lineNum">     777 </span>            :             c_zscal(NR*NR,z,QY,1);
<span class="lineNum">     778 </span>            :         }
<span class="lineNum">     779 </span>            :     }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span><span class="lineCov">         64 : }</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : /************************************************************************************************/
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            : template &lt;class T&gt;
<span class="lineNum">     786 </span><span class="lineCov">          2 : void InjectionBeyn&lt;T&gt;::init_Y_matrix(CPX *Y,int NM,int N)</span>
<span class="lineNum">     787 </span>            : {
<span class="lineNum">     788 </span>            :     //all the CPUs should see the same Y
<span class="lineNum">     789 </span>            :     int IR,IC;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :     //srand(time(0));
<span class="lineNum">     792 </span><span class="lineCov">          2 :     srand(0);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineCov">        146 :     for(IC=0;IC&lt;NM;IC++){</span>
<span class="lineNum">     795 </span><span class="lineCov">      20880 :         for(IR=0;IR&lt;N;IR++){</span>
<span class="lineNum">     796 </span><span class="lineCov">      20736 :             Y[IR+IC*N] = CPX(randn(),randn());</span>
<span class="lineNum">     797 </span>            :         }
<span class="lineNum">     798 </span><span class="lineCov">        576 :         c_zscal(N,CPX(1.0/c_dznrm2(N,&amp;Y[IC*N],1),0.0),&amp;Y[IC*N],1);</span>
<span class="lineNum">     799 </span>            :     }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : /************************************************************************************************/
<a name="804"><span class="lineNum">     804 </span>            : </a>
<span class="lineNum">     805 </span>            : template &lt;class T&gt;
<span class="lineNum">     806 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::init_matrix_single(TCSR&lt;CPX&gt; *A,TCSR&lt;CPX&gt; *B,TCSR&lt;T&gt; *D,\</span>
<span class="lineNum">     807 </span>            :                                            TCSR&lt;T&gt; *P,int ND,int NP)
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :     int i,j;
<span class="lineNum">     811 </span>            :     
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     A-&gt;copy_contain(D,1.0);</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     B-&gt;n_nonzeros = 0;</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;P-&gt;size;i++){</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         B-&gt;index_i[i] = 0;</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         for(j=P-&gt;edge_i[i]-P-&gt;findx;j&lt;P-&gt;edge_i[i+1]-P-&gt;findx;j++){</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :             B-&gt;index_j[B-&gt;n_nonzeros] = P-&gt;index_j[j]-P-&gt;findx+ND-NP+B-&gt;findx;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :             B-&gt;nnz[B-&gt;n_nonzeros]     = convert&lt;CPX,T&gt;(P-&gt;nnz[j]);</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :             B-&gt;index_i[i]++;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :             B-&gt;n_nonzeros++;</span>
<span class="lineNum">     827 </span>            :         }
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     B-&gt;get_row_edge();</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : /************************************************************************************************/
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            : template &lt;class T&gt;
<span class="lineNum">     836 </span><span class="lineNoCov">          0 : void InjectionBeyn&lt;T&gt;::init_matrix_double(TCSR&lt;CPX&gt; *A,TCSR&lt;CPX&gt; *B,TCSR&lt;T&gt; *D,\</span>
<span class="lineNum">     837 </span>            :                                            TCSR&lt;T&gt; *P,int ND,int NP)
<span class="lineNum">     838 </span>            : {
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :     int i,j;
<span class="lineNum">     841 </span>            :     int row_ind;
<span class="lineNum">     842 </span>            :     int col_ind;
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     CPX *line = new CPX[D-&gt;size];</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     A-&gt;n_nonzeros = 0;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     B-&gt;n_nonzeros = 0;</span>
<span class="lineNum">     847 </span>            :   
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;ND;i++){ </span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         A-&gt;index_i[i] = 0;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         B-&gt;index_i[i] = 0;</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         if(i&lt;ND/slab_per_bc){</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             init_var(line,D-&gt;size);</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :             row_ind = i+ND/2-ND/slab_per_bc;</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :             for(j=D-&gt;edge_i[row_ind]-D-&gt;findx;j&lt;D-&gt;edge_i[row_ind+1]-D-&gt;findx;j++){</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                 col_ind           = D-&gt;index_j[j]-D-&gt;findx;</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                 if((col_ind&lt;ND/2)||(col_ind&gt;=ND-ND/slab_per_bc)){</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                     line[col_ind] = convert&lt;CPX,T&gt;(D-&gt;nnz[j]);</span>
<span class="lineNum">     865 </span>            :                 }
<span class="lineNum">     866 </span>            :             }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :             for(j=P-&gt;edge_i[row_ind]-P-&gt;findx;j&lt;P-&gt;edge_i[row_ind+1]-P-&gt;findx;j++){</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                 col_ind                   = P-&gt;index_j[j]-P-&gt;findx+ND-NP;</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :                 if((col_ind&lt;ND/2)||(col_ind&gt;=ND-ND/slab_per_bc)){</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :                     line[col_ind]         = line[col_ind]+convert&lt;CPX,T&gt;(P-&gt;nnz[j]);</span>
<span class="lineNum">     874 </span>            :                 }
<span class="lineNum">     875 </span>            :                   
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :                 B-&gt;index_j[B-&gt;n_nonzeros] = col_ind-ND+ND/slab_per_bc+B-&gt;findx;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :                 B-&gt;nnz[B-&gt;n_nonzeros]     = convert&lt;CPX,T&gt;(P-&gt;nnz[j]);</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :                 B-&gt;index_i[i]++;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                 B-&gt;n_nonzeros++;</span>
<span class="lineNum">     881 </span>            :             }
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :             if(slab_per_bc&gt;2){ </span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :                 row_ind = i+ND/2-2*ND/slab_per_bc;</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                 for(j=D-&gt;edge_i[row_ind]-D-&gt;findx;j&lt;D-&gt;edge_i[row_ind+1]-D-&gt;findx;j++){</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :                     col_ind           = D-&gt;index_j[j]-D-&gt;findx+ND/slab_per_bc;</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                     if((col_ind&gt;=ND/2)&amp;&amp;(col_ind&lt;ND-ND/slab_per_bc)){</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                         line[col_ind] = convert&lt;CPX,T&gt;(D-&gt;nnz[j]);</span>
<span class="lineNum">     893 </span>            :                     }
<span class="lineNum">     894 </span>            :                 }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 for(j=P-&gt;edge_i[row_ind]-P-&gt;findx;j&lt;P-&gt;edge_i[row_ind+1]-P-&gt;findx;j++){</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                     col_ind           = P-&gt;index_j[j]-P-&gt;findx+ND-NP+ND/slab_per_bc;</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                     if((col_ind&gt;=ND/2)&amp;&amp;(col_ind&lt;ND-ND/slab_per_bc)){</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :                         line[col_ind] = line[col_ind]+convert&lt;CPX,T&gt;(P-&gt;nnz[j]);</span>
<span class="lineNum">     902 </span>            :                     }
<span class="lineNum">     903 </span>            :                 }
<span class="lineNum">     904 </span>            :             }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :             for(j=0;j&lt;D-&gt;size;j++){</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :                 if(abs(line[j])){</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                     A-&gt;nnz[A-&gt;n_nonzeros]     = line[j];</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                     A-&gt;index_j[A-&gt;n_nonzeros] = j+A-&gt;findx;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                     A-&gt;index_i[i]++;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                     A-&gt;n_nonzeros++;</span>
<span class="lineNum">     915 </span>            :                 }
<span class="lineNum">     916 </span>            :             }
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :         }else{
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :             A-&gt;index_j[A-&gt;n_nonzeros] = i-ND/slab_per_bc+A-&gt;findx;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :             A-&gt;nnz[A-&gt;n_nonzeros]     = CPX(1.0,0.0);</span>
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :             A-&gt;index_i[i]++;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :             A-&gt;n_nonzeros++;</span>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :             B-&gt;index_j[B-&gt;n_nonzeros] = i+B-&gt;findx;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :             B-&gt;nnz[B-&gt;n_nonzeros]     = CPX(1.0,0.0);</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :             B-&gt;index_i[i]++;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :             B-&gt;n_nonzeros++;</span>
<span class="lineNum">     931 </span>            :         }
<span class="lineNum">     932 </span>            :     }
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     A-&gt;get_row_edge();</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     B-&gt;get_row_edge();</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     delete[] line;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : /************************************************************************************************/
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : template &lt;class T&gt;
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : int InjectionBeyn&lt;T&gt;::get_type(TCSR&lt;CPX&gt; *T01,CPX* Vin,CPX kin,double *dEk_dk,int ind_to_keep,\</span>
<span class="lineNum">     943 </span>            :                                 int sign)
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span>            :     int type;
<span class="lineNum">     946 </span>            :     //double dEk;
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     *dEk_dk = 0.0;</span>
<span class="lineNum">     949 </span>            :     
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     if(((imag(kin)&lt;imag_limit)&amp;&amp;(imag(kin)&gt;-imag_limit))){</span>
<span class="lineNum">     951 </span>            :         
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         *dEk_dk = sign*calc_derivative(T01,Vin,kin);</span>
<span class="lineNum">     953 </span>            :  
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         if(*dEk_dk&gt;0){</span>
<span class="lineNum">     955 </span>            :           type = 1;
<span class="lineNum">     956 </span>            :         }else{
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :           type = -1;</span>
<span class="lineNum">     958 </span>            :         }
<span class="lineNum">     959 </span>            :         
<span class="lineNum">     960 </span>            :     }else{
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         if(imag(kin)&gt;imag_limit){</span>
<span class="lineNum">     963 </span>            :             type = sign;
<span class="lineNum">     964 </span>            :         }else{
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :             type = -sign;</span>
<span class="lineNum">     966 </span>            :         }
<span class="lineNum">     967 </span>            :         /*
<span class="lineNum">     968 </span>            :         if(ind_to_keep==2){
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :             dEk = sign*calc_derivative(T01,Vin,kin);
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :             if(dEk&gt;0){
<span class="lineNum">     973 </span>            :                 type = 1;
<span class="lineNum">     974 </span>            :             }else{
<span class="lineNum">     975 </span>            :                 type = -1;
<span class="lineNum">     976 </span>            :             }
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :         }else{
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :             if(imag(kin)&gt;imag_limit){
<span class="lineNum">     981 </span>            :                 type = sign;
<span class="lineNum">     982 </span>            :             }else{
<span class="lineNum">     983 </span>            :                 type = -sign;
<span class="lineNum">     984 </span>            :             }
<span class="lineNum">     985 </span>            :         }
<span class="lineNum">     986 </span>            :         */
<span class="lineNum">     987 </span>            :     }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     return type;</span>
<span class="lineNum">     990 </span>            :     
<span class="lineNum">     991 </span>            : }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            : /************************************************************************************************/
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : template &lt;class T&gt;
<span class="lineNum">     996 </span><span class="lineNoCov">          0 : double InjectionBeyn&lt;T&gt;::calc_derivative(TCSR&lt;CPX&gt; *T01,CPX* Vin,CPX kin)</span>
<span class="lineNum">     997 </span>            : {
<span class="lineNum">     998 </span>            :     double dEk_dk;
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     CPX *Vout = new CPX[T01-&gt;size];</span>
<span class="lineNum">    1000 </span>            :     
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     T01-&gt;mat_vec_mult(Vin,Vout,1);</span>
<span class="lineNum">    1002 </span>            :     //no minus sign in dEk_dk because T01=-H01 used instead of H01
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     dEk_dk = 2.0*imag(c_zdotc(T01-&gt;size,Vin,1,Vout,1)*exp(CPX(0.0,1.0)*kin)); </span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     delete[] Vout;</span>
<span class="lineNum">    1006 </span>            :     
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     return dEk_dk;</span>
<span class="lineNum">    1008 </span>            : }
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            : /************************************************************************************************/
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            : template &lt;class T&gt;
<span class="lineNum">    1013 </span><span class="lineCov">          2 : int InjectionBeyn&lt;T&gt;::parallel_decompose(CPX *Q1,CPX *Q2,int ND,int NM, MPI_Comm comm)</span>
<span class="lineNum">    1014 </span>            : {
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineCov">          2 :     double *Sval = new double[NM];</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineCov">          2 :     int icontxt=MPI_Comm_c2f(comm);</span>
<span class="lineNum">    1019 </span><span class="lineCov">          2 :     int nprowcol[2]={0,0};</span>
<span class="lineNum">    1020 </span><span class="lineCov">          2 :     MPI_Dims_create(loc_size,2,nprowcol);</span>
<span class="lineNum">    1021 </span><span class="lineCov">          2 :     int nprow = nprowcol[0];</span>
<span class="lineNum">    1022 </span><span class="lineCov">          2 :     int npcol = nprowcol[1];</span>
<span class="lineNum">    1023 </span>            :     int myrow, mycol;
<span class="lineNum">    1024 </span><span class="lineCov">          2 :     char gridr[1] = {'R'};</span>
<span class="lineNum">    1025 </span><span class="lineCov">          4 :     Cblacs_gridinit(&amp;icontxt,gridr,nprow,npcol);</span>
<span class="lineNum">    1026 </span><span class="lineCov">          4 :     Cblacs_gridinfo(icontxt,&amp;nprow,&amp;npcol,&amp;myrow,&amp;mycol);</span>
<span class="lineNum">    1027 </span><span class="lineCov">          2 :     int row_per_processor    = ND/nprow;</span>
<span class="lineNum">    1028 </span><span class="lineCov">          2 :     int block_per_rprocessor = int(ceil(double(row_per_processor)/64));</span>
<span class="lineNum">    1029 </span><span class="lineCov">          2 :     int mb                   = row_per_processor/block_per_rprocessor;</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineCov">          2 :     int col_per_processor    = NM/npcol;</span>
<span class="lineNum">    1032 </span><span class="lineCov">          2 :     int block_per_cprocessor = int(ceil(double(col_per_processor)/64));</span>
<span class="lineNum">    1033 </span><span class="lineCov">          2 :     int nb                   = col_per_processor/block_per_cprocessor;</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineCov">          2 :     nb=(nb+mb)/2;</span>
<span class="lineNum">    1036 </span><span class="lineCov">          2 :     mb=nb;</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">          6 :     int rloc      = max(1,c_numroc(ND,mb,myrow,0,nprow));</span>
<span class="lineNum">    1039 </span><span class="lineCov">          4 :     int cloc      = c_numroc(NM,nb,mycol,0,npcol);</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     int info;
<span class="lineNum">    1042 </span>            :     int descQ[9];
<span class="lineNum">    1043 </span><span class="lineCov">          4 :     c_descinit(descQ,ND,NM,ND,NM,0,0,icontxt,ND,&amp;info);</span>
<span class="lineNum">    1044 </span>            :     int descq[9]; //LOCAL MATRICES ALL (ND,NM) EVEN IF LESS SPACE NEEDED
<span class="lineNum">    1045 </span><span class="lineCov">          4 :     c_descinit(descq,ND,NM,mb,nb,0,0,icontxt,rloc,&amp;info);</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineCov">      20738 :     CPX *q_dist      = new CPX[2*rloc*cloc];</span>
<span class="lineNum">    1048 </span><span class="lineCov">      20738 :     CPX *u_dist      = new CPX[2*rloc*cloc];</span>
<span class="lineNum">    1049 </span><span class="lineCov">      20738 :     CPX *vtrans_dist = new CPX[2*rloc*cloc];</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineCov">          6 :     c_pzgeadd('N',ND,NM,1.0,Q1,1,1,descQ,0.0,q_dist,1,1,descq);</span>
<span class="lineNum">    1052 </span>            :     
<span class="lineNum">    1053 </span><span class="lineCov">          2 :     int lwork     = -1;</span>
<span class="lineNum">    1054 </span><span class="lineCov">          2 :     CPX workq;</span>
<span class="lineNum">    1055 </span>            :     double rworkq;
<span class="lineNum">    1056 </span><span class="lineCov">          2 :     CPX *work     = &amp;workq;</span>
<span class="lineNum">    1057 </span><span class="lineCov">          2 :     double *rwork = &amp;rworkq;</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">          2 :     c_pzgesvd('V','V',ND,NM,q_dist,1,1,descq,Sval,u_dist,1,1,descq,vtrans_dist,1,1,descq,work,lwork,rwork,&amp;info);</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineCov">          2 :     lwork = 2*int(real(workq));</span>
<span class="lineNum">    1062 </span><span class="lineCov">      67974 :     work  = new CPX[lwork];</span>
<span class="lineNum">    1063 </span><span class="lineCov">          2 :     rwork = new double[2*int(rworkq)];</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span><span class="lineCov">          2 :     c_pzgesvd('V','V',ND,NM,q_dist,1,1,descq,Sval,u_dist,1,1,descq,vtrans_dist,1,1,descq,work,lwork,rwork,&amp;info);</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineCov">          4 :     delete[] work;</span>
<span class="lineNum">    1068 </span><span class="lineCov">          2 :     delete[] rwork;</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span><span class="lineCov">          6 :     c_pzgeadd('N',ND,NM,1.0,u_dist,1,1,descq,0.0,Q1,1,1,descQ);</span>
<span class="lineNum">    1071 </span><span class="lineCov">          6 :     c_pzgeadd('N',ND,NM,1.0,Q2,1,1,descQ,0.0,q_dist,1,1,descq);</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineCov">          2 :     int NM_new = 0;</span>
<span class="lineNum">    1074 </span><span class="lineCov">         72 :     while(NM_new&lt;ND &amp;&amp; Sval[NM_new]&gt;svd_fac*Sval[0]*ND*(numeric_limits&lt;double&gt;::epsilon)()) NM_new++;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineCov">      10370 :     CPX *UtxQ2_dist = new CPX[rloc*cloc];</span>
<span class="lineNum">    1077 </span><span class="lineCov">          6 :     c_pzgemm('C','N',NM_new,NM,ND,CPX(1.0,0.0),u_dist,1,1,descq,q_dist,1,1,descq,CPX(0.0,0.0),UtxQ2_dist,1,1,descq);</span>
<span class="lineNum">    1078 </span><span class="lineCov">          2 :     delete[] u_dist;</span>
<span class="lineNum">    1079 </span><span class="lineCov">          6 :     c_pzgemm('N','C',NM_new,NM_new,NM,CPX(1.0,0.0),UtxQ2_dist,1,1,descq,vtrans_dist,1,1,descq,CPX(0.0,0.0),q_dist,1,1,descq);</span>
<span class="lineNum">    1080 </span><span class="lineCov">          2 :     delete[] UtxQ2_dist;</span>
<span class="lineNum">    1081 </span><span class="lineCov">          2 :     delete[] vtrans_dist;</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :     int descQ_out[9];
<span class="lineNum">    1084 </span><span class="lineCov">          4 :     c_descinit(descQ_out,NM_new,NM_new,NM_new,NM_new,0,0,icontxt,NM_new,&amp;info);</span>
<span class="lineNum">    1085 </span><span class="lineCov">          6 :     c_pzgeadd('N',NM_new,NM_new,1.0,q_dist,1,1,descq,0.0,Q2,1,1,descQ_out);</span>
<span class="lineNum">    1086 </span><span class="lineCov">          2 :     delete[] q_dist;</span>
<span class="lineNum">    1087 </span><span class="lineCov">        142 :     if(!loc_rank) for (int inm=0;inm&lt;NM_new;inm++) c_zscal(NM_new,CPX(1.0/Sval[inm],0.0),&amp;Q2[inm*NM_new],1);</span>
<span class="lineNum">    1088 </span><span class="lineCov">          2 :     delete[] Sval;</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineCov">          4 :     Cblacs_gridexit(icontxt);</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span><span class="lineCov">          2 :     return NM_new;</span>
<span class="lineNum">    1093 </span>            : }
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            : /************************************************************************************************/
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            : template &lt;class T&gt;
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 : int InjectionBeyn&lt;T&gt;::decompose(CPX *Q1,CPX *Q2,int ND,int NM)</span>
<span class="lineNum">    1099 </span>            : {
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     double *Sval = new double[NM];</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     CPX *vtrans = new CPX[NM*NM];</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     if (svd(Q1,vtrans,Sval,ND,NM)) return 0;</span>
<span class="lineNum">    1104 </span>            :     int NM_new = 0;
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     while(NM_new&lt;ND &amp;&amp; Sval[NM_new]&gt;svd_fac*Sval[0]*ND*(numeric_limits&lt;double&gt;::epsilon)()) NM_new++;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     CPX *UtxQ2 = new CPX[NM_new*NM];</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     c_zgemm('C','N',NM_new,NM,ND,CPX(1.0,0.0),Q1,ND,Q2,ND,CPX(0.0,0.0),UtxQ2,NM_new);</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     c_zgemm('N','C',NM_new,NM_new,NM,CPX(1.0,0.0),UtxQ2,NM_new,vtrans,NM,CPX(0.0,0.0),Q2,NM_new);</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     delete[] UtxQ2;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     delete[] vtrans;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     for (int inm=0;inm&lt;NM_new;inm++) c_zscal(NM_new,CPX(1.0/Sval[inm],0.0),&amp;Q2[inm*NM_new],1);</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     delete[] Sval;</span>
<span class="lineNum">    1113 </span>            :     return NM_new;
<span class="lineNum">    1114 </span>            : }
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            : /************************************************************************************************/
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            : template &lt;class T&gt;
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 : int InjectionBeyn&lt;T&gt;::svd(CPX *u,CPX *vtrans,double *Sval,int ND,int NM)</span>
<span class="lineNum">    1120 </span>            : {
<span class="lineNum">    1121 </span>            :     
<span class="lineNum">    1122 </span>            :     int info;
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     int lwork     = -1;</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     double *rwork = new double[NM*max(5*NM+7,2*ND+2*NM+1)];</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     int *iwork    = new int[8*NM];</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     CPX workq;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     CPX *work     = &amp;workq;</span>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     c_zgesdd('O',ND,NM,u,ND,Sval,NULL,1,vtrans,NM,work,lwork,rwork,iwork,&amp;info);</span>
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     lwork = int(real(workq));</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     work  = new CPX[lwork];</span>
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     c_zgesdd('O',ND,NM,u,ND,Sval,NULL,1,vtrans,NM,work,lwork,rwork,iwork,&amp;info);</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     delete[] work;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     delete[] rwork;</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :     delete[] iwork;</span>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     return info;</span>
<span class="lineNum">    1141 </span>            : }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : /************************************************************************************************/
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            : template &lt;class T&gt;
<span class="lineNum">    1146 </span><span class="lineCov">          2 : int InjectionBeyn&lt;T&gt;::eig(CPX *a,int n,CPX *lambda)</span>
<span class="lineNum">    1147 </span>            : {
<span class="lineNum">    1148 </span>            :     
<span class="lineNum">    1149 </span><span class="lineCov">          2 :     char jobvl    = 'N';</span>
<span class="lineNum">    1150 </span><span class="lineCov">          2 :     char jobvr    = 'V';</span>
<span class="lineNum">    1151 </span><span class="lineCov">          2 :     int lda       = n;</span>
<span class="lineNum">    1152 </span><span class="lineCov">          2 :     CPX *vl       = NULL;</span>
<span class="lineNum">    1153 </span><span class="lineCov">          2 :     int ldvl      = 1;</span>
<span class="lineNum">    1154 </span><span class="lineCov">       2452 :     CPX *vr       = new CPX[n*n];</span>
<span class="lineNum">    1155 </span><span class="lineCov">          2 :     int ldvr      = n;</span>
<span class="lineNum">    1156 </span><span class="lineCov">          2 :     int lwork     = -1;</span>
<span class="lineNum">    1157 </span>            :     int info;
<span class="lineNum">    1158 </span><span class="lineCov">          2 :     CPX worktest;</span>
<span class="lineNum">    1159 </span><span class="lineCov">          2 :     CPX *work     = &amp;worktest;</span>
<span class="lineNum">    1160 </span><span class="lineCov">          2 :     double *rwork = new double[2*n];</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineCov">          2 :     c_zgeev(jobvl,jobvr,n,a,lda,lambda,vl,ldvl,vr,ldvr,work,lwork,rwork,&amp;info);</span>
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span><span class="lineCov">          2 :     lwork = int(real(worktest));</span>
<span class="lineNum">    1165 </span><span class="lineCov">       9104 :     work  = new CPX[lwork];</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineCov">          2 :     c_zgeev(jobvl,jobvr,n,a,lda,lambda,vl,ldvl,vr,ldvr,work,lwork,rwork,&amp;info);</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineCov">          2 :     delete[] work;</span>
<span class="lineNum">    1170 </span><span class="lineCov">          2 :     delete[] rwork;</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">          2 :     c_zcopy(n*n,vr,1,a,1);</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">          2 :     delete[] vr;</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span><span class="lineCov">          2 :     return info;</span>
<span class="lineNum">    1177 </span>            : }
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            : /************************************************************************************************/
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
