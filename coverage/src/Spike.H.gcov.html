<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - cp2k-omen_cov.info - src/Spike.H</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - Spike.H<span style="font-size: 80%;"> (source / <a href="Spike.H.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">cp2k-omen_cov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-12-30 22:09:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            : Copyright (c) 2017 ETH Zurich
<span class="lineNum">       3 </span>            : Sascha Brueck, Mauro Calderara, Mohammad Hossein Bani-Hashemian, and Mathieu Luisier
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      10 </span>            : */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef SPIKE_H_
<span class="lineNum">      13 </span>            : #define SPIKE_H_
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;vector&gt;
<span class="lineNum">      16 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;sstream&gt;
<span class="lineNum">      20 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &lt;mpi.h&gt;
<span class="lineNum">      23 </span>            : #include &quot;Blas.H&quot;
<span class="lineNum">      24 </span>            : #include &quot;CSR.H&quot;
<span class="lineNum">      25 </span>            : #include &quot;Types.H&quot;
<span class="lineNum">      26 </span>            : #include &quot;Utilities.H&quot;
<span class="lineNum">      27 </span>            : #include &quot;Pardiso.H&quot;
<span class="lineNum">      28 </span>            : #include &quot;LinearSolver.H&quot;
<span class="lineNum">      29 </span>            : #include &quot;mpi.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : // Debugging
<span class="lineNum">      33 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">      34 </span>            : #include &lt;cstdio&gt;
<span class="lineNum">      35 </span>            : #include &lt;iostream&gt;
<span class="lineNum">      36 </span>            : using std::cout;
<span class="lineNum">      37 </span>            : #define SPIKE_DEBUG_PATH &quot;/users/camauro/transport/c++/src/dbg/&quot;
<span class="lineNum">      38 </span>            : #endif /* SPIKE_DEBUG */
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : template &lt;typename T&gt;
<span class="lineNum">      42 </span>            : class Spike {
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :  public: 
<span class="lineNum">      45 </span>            :   Spike(TCSR&lt;T&gt;* matrix, T* RHS, int RHS_col, MPI_Comm communicator,
<span class="lineNum">      46 </span>            :         bool diagonal_dense = false);
<span class="lineNum">      47 </span>            :   ~Spike();
<span class="lineNum">      48 </span>            :   void solve_full(T* sol);
<span class="lineNum">      49 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">      50 </span>            :   void debug();
<span class="lineNum">      51 </span>            : #endif /* SPIKE_DEBUG */
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :  private:        
<span class="lineNum">      54 </span>            :     
<span class="lineNum">      55 </span>            :   // Main Part of the alogrithm
<span class="lineNum">      56 </span>            :   void preprocess();
<span class="lineNum">      57 </span>            :   void postprocess();
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   // Preprocess methods
<span class="lineNum">      60 </span>            :   void prepare_D();
<span class="lineNum">      61 </span>            :   void calculate_spikes();
<span class="lineNum">      62 </span>            :   void calculate_G();
<span class="lineNum">      63 </span>            :   void delete_D();
<span class="lineNum">      64 </span>            :   void prepare_send_buffer_spikes();
<span class="lineNum">      65 </span>            :   void distribute_reduced_spikes();
<span class="lineNum">      66 </span>            :   void prepare_send_buffer_G();
<span class="lineNum">      67 </span>            :   void distribute_reduced_G();
<span class="lineNum">      68 </span>            :   void prepare_sparsity_pattern();
<span class="lineNum">      69 </span>            :   
<span class="lineNum">      70 </span>            :   // Postprocess methods
<span class="lineNum">      71 </span>            :   void solve_reduced_system();
<span class="lineNum">      72 </span>            :   void distribute_Xr();
<span class="lineNum">      73 </span>            :   void expand_reduced_system();
<span class="lineNum">      74 </span>            :   
<span class="lineNum">      75 </span>            :   // Utils (TODO: most of these belong into LinAlg)
<span class="lineNum">      76 </span>            :   void get_dense_from_sparse_c(TCSR&lt;T&gt;* matrix_in, 
<span class="lineNum">      77 </span>            :                                int start_row, int start_col, 
<span class="lineNum">      78 </span>            :                                int end_row, int end_col, 
<span class="lineNum">      79 </span>            :                                T* matrix_out);
<span class="lineNum">      80 </span>            :   void get_dense_from_sparse_f(TCSR&lt;T&gt;* matrix_in,
<span class="lineNum">      81 </span>            :                                int start_row, int start_col, 
<span class="lineNum">      82 </span>            :                                int end_row, int end_col,
<span class="lineNum">      83 </span>            :                                T* matrix_out);
<span class="lineNum">      84 </span>            :   TCSR&lt;T&gt;* get_sparse_from_sparse(TCSR&lt;T&gt;* matrix_in,
<span class="lineNum">      85 </span>            :                                   int start_row, int start_col,
<span class="lineNum">      86 </span>            :                                   int end_row, int end_col);
<span class="lineNum">      87 </span>            :   
<span class="lineNum">      88 </span>            :   int  get_max_column(TCSR&lt;T&gt;* matrix_in);
<span class="lineNum">      89 </span>            :   bool has_right_hand_side();
<span class="lineNum">      90 </span>            :   void set_mpi_dataype();
<span class="lineNum">      91 </span>            :   void calculate_lu_decomposition(T* matrix_in, int row, int col);
<span class="lineNum">      92 </span>            :   void solve_linear_system_dense(T* LU, int row, int col, T* B, int B_cols); 
<span class="lineNum">      93 </span>            :   void solve_linear_system_sparse(TCSR&lt;T&gt;* M, T* B, int B_cols, T* X);
<span class="lineNum">      94 </span>            :   void spy(T* matrix, int row, int column);
<span class="lineNum">      95 </span>            :   void spy(TCSR&lt;T&gt;* matrix, int row, int column);
<span class="lineNum">      96 </span>            :   void full(T* matrix, int row, int column);
<span class="lineNum">      97 </span>            :   void full(TCSR&lt;T&gt;* matrix, int row, int col);
<span class="lineNum">      98 </span>            :   void print_array(T* matrix, int size);
<span class="lineNum">      99 </span>            :   void merge_matrix_f(T* inout, int ldo, int start_row, 
<span class="lineNum">     100 </span>            :                       int start_column, T* in, int size, int loi,
<span class="lineNum">     101 </span>            :                       int length_column);
<span class="lineNum">     102 </span>            :   void merge_matrix_c(T* inout, int ldo, int start_row, 
<span class="lineNum">     103 </span>            :                       int start_column, T* in, int size, int loi,
<span class="lineNum">     104 </span>            :                       int length_column);
<span class="lineNum">     105 </span>            :   T get_sparse_matrix_value(TCSR&lt;T&gt;* Mat, int i, int j);
<span class="lineNum">     106 </span>            :   void transpose_dense_matrix(T* mat, int row, int col);
<span class="lineNum">     107 </span>            :   void trans(T* src, T* dst, const int N, const int M); 
<span class="lineNum">     108 </span>            :   void xLACPY(char UPLO, int M, int N, T* A, int LDA, T* B, int LDB);
<span class="lineNum">     109 </span>            :   void xGEMM(char TRANSA, char TRANSB, int M, int N, int K, T ALPHA, T* A,
<span class="lineNum">     110 </span>            :              int LDA, T* B, int LDB, T BETA, T* C, int LDC);
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   
<span class="lineNum">     113 </span>            :   // Members
<span class="lineNum">     114 </span>            :   TCSR&lt;T&gt;* M;                     // Partion Matrix
<span class="lineNum">     115 </span>            :   int M_size, M_rows, M_cols;
<span class="lineNum">     116 </span>            :   std::vector&lt;int&gt; partition_lines;
<span class="lineNum">     117 </span>            :   int bandwidth;
<span class="lineNum">     118 </span>            :   
<span class="lineNum">     119 </span>            :   T* F;                           // Local part of right hand side (RHS).
<span class="lineNum">     120 </span>            :   int F_size, F_rows, F_cols;             
<span class="lineNum">     121 </span>            :   
<span class="lineNum">     122 </span>            :   T* D_dense;                     // Diagonal Block
<span class="lineNum">     123 </span>            :   TCSR&lt;T&gt;* D_sparse;
<span class="lineNum">     124 </span>            :   int D_size, D_rows, D_cols;
<span class="lineNum">     125 </span>            :   bool D_is_dense;
<span class="lineNum">     126 </span>            :   
<span class="lineNum">     127 </span>            :   T* G;                           // Local part of intermediate RHS.
<span class="lineNum">     128 </span>            :   int G_size, G_rows, G_cols;        
<span class="lineNum">     129 </span>            :   
<span class="lineNum">     130 </span>            :   T* V;                           // V spike.
<span class="lineNum">     131 </span>            :   int V_size, V_rows, V_cols; 
<span class="lineNum">     132 </span>            :   
<span class="lineNum">     133 </span>            :   T* W;                           // W spike.
<span class="lineNum">     134 </span>            :   int W_size, W_rows, W_cols; 
<span class="lineNum">     135 </span>            :   
<span class="lineNum">     136 </span>            :   TCSR&lt;T&gt;* Sr;                    // Reduced system
<span class="lineNum">     137 </span>            :   int Sr_size, Sr_rows, Sr_cols;
<span class="lineNum">     138 </span>            :     
<span class="lineNum">     139 </span>            :   T* Gr;                          // Reduced system
<span class="lineNum">     140 </span>            :   int Gr_size, Gr_rows, Gr_cols;
<span class="lineNum">     141 </span>            :   
<span class="lineNum">     142 </span>            :   T* Xr;                          // Reduced system
<span class="lineNum">     143 </span>            :   int Xr_size, Xr_rows, Xr_cols;
<span class="lineNum">     144 </span>            :   
<span class="lineNum">     145 </span>            :   T* Xr_local;                    // Reduced system, Bottom and Top of Xr 
<span class="lineNum">     146 </span>            :                                   // on local rank  
<span class="lineNum">     147 </span>            :   int Xr_local_size, Xr_local_rows, Xr_local_cols;
<span class="lineNum">     148 </span>            :             
<span class="lineNum">     149 </span>            :   T* Sr_sendbuffer;               // Send buffer for reduced system
<span class="lineNum">     150 </span>            :   int Sr_sendbuffer_size, Sr_sendbuffer_rows, Sr_sendbuffer_cols;
<span class="lineNum">     151 </span>            :   
<span class="lineNum">     152 </span>            :   T* Gr_sendbuffer;               // Send buffer for reduced system
<span class="lineNum">     153 </span>            :   int Gr_sendbuffer_size, Gr_sendbuffer_rows, Gr_sendbuffer_cols;
<span class="lineNum">     154 </span>            :   
<span class="lineNum">     155 </span>            :   T* X;                           // final solution per rank; 
<span class="lineNum">     156 </span>            :   int X_size, X_rows, X_cols;
<span class="lineNum">     157 </span>            :   
<span class="lineNum">     158 </span>            :   int spike_width;
<span class="lineNum">     159 </span>            :   int partition_height;
<span class="lineNum">     160 </span>            :   int* ipiv;                      // Pivot vector for factorization.
<span class="lineNum">     161 </span>            :   
<span class="lineNum">     162 </span>            :   // MPI
<span class="lineNum">     163 </span>            :   MPI_Comm        comm;           // MPI Communicator
<span class="lineNum">     164 </span>            :   MPI_Datatype    MPI_data_type;  // Data type 
<span class="lineNum">     165 </span>            :   MPI_Win         win_Sr, win_Gr, win_Xr, win_X;
<span class="lineNum">     166 </span>            :   int rank; 
<span class="lineNum">     167 </span>            :   int num_ranks;
<span class="lineNum">     168 </span>            :   int master_rank; 
<span class="lineNum">     169 </span>            :   int last_rank;
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :   // Debugging (inactive unless SPIKE_DEBUG preprocessor is defined)
<span class="lineNum">     172 </span>            :   string debug_path;
<span class="lineNum">     173 </span>            :   void dump(TCSR&lt;T&gt;* matrix, const char* prefix);
<span class="lineNum">     174 </span>            :   void dump_c(T* matrix, int rows, int cols, const char* prefix);
<span class="lineNum">     175 </span>            :   void dump_f(T* matrix, int rows, int cols, const char* prefix);
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     178 </span>            :   // Timing
<span class="lineNum">     179 </span>            :   double start_time;
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span>            : };
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : template&lt;typename T&gt;
<span class="lineNum">     186 </span>            : Spike&lt;T&gt;:: Spike(TCSR&lt;T&gt;* matrix, T* RHS, int RHS_col, MPI_Comm communicator,
<span class="lineNum">     187 </span>            :                  bool diagonal_dense) {
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   MPI_Comm_rank(communicator, &amp;rank);
<span class="lineNum">     190 </span>            :   MPI_Comm_size(communicator, &amp;num_ranks);
<span class="lineNum">     191 </span>            :   set_mpi_dataype();
<span class="lineNum">     192 </span>            :   master_rank       = 0;
<span class="lineNum">     193 </span>            :   last_rank         = num_ranks - 1;
<span class="lineNum">     194 </span>            :   comm              = communicator;
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Determine the partitioning
<span class="lineNum">     197 </span>            :   int* partition_sizes = new int[num_ranks];
<span class="lineNum">     198 </span>            :   MPI_Allgather(&amp;matrix-&gt;size, 1, MPI_INT, partition_sizes, 1, MPI_INT,
<span class="lineNum">     199 </span>            :                 communicator);
<span class="lineNum">     200 </span>            :   partition_lines.resize(num_ranks + 1);
<span class="lineNum">     201 </span>            :   for (int i = 1; i &lt; num_ranks + 1; ++i) {
<span class="lineNum">     202 </span>            :     partition_lines[i] = partition_lines[i - 1] + partition_sizes[i - 1];
<span class="lineNum">     203 </span>            :   } 
<span class="lineNum">     204 </span>            :   delete[] partition_sizes;
<span class="lineNum">     205 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">     206 </span>            :   printf(&quot;rank %d: AUTODETECT: partition lines @&quot;, rank);
<span class="lineNum">     207 </span>            :   for (int i = 0; i &lt; num_ranks + 1; ++i) {
<span class="lineNum">     208 </span>            :     printf(&quot;%d &quot;, partition_lines[i]);
<span class="lineNum">     209 </span>            :   }
<span class="lineNum">     210 </span>            :   printf(&quot;\n&quot;);
<span class="lineNum">     211 </span>            : #endif
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   partition_height  = partition_lines[rank + 1] - partition_lines[rank];
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   // Determine the bandwidth
<span class="lineNum">     216 </span>            :   // TODO: determining the width of B and/or C would probably result in a
<span class="lineNum">     217 </span>            :   // tighter bandwidth, which would be a good thing.
<span class="lineNum">     218 </span>            :   int local_bandwidth = 0;
<span class="lineNum">     219 </span>            :   for (int row = 0; row &lt; partition_height; ++row) {
<span class="lineNum">     220 </span>            :     for (int index = matrix-&gt;edge_i[row]; index &lt; matrix-&gt;edge_i[row + 1];
<span class="lineNum">     221 </span>            :        ++index) {
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :       int i = row + partition_lines[rank];
<span class="lineNum">     224 </span>            :       int j = matrix-&gt;index_j[index] - matrix-&gt;findx;
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :       // ignore explicit zeros
<span class="lineNum">     227 </span>            :       if (abs(matrix-&gt;nnz[index]) != 0.0) {
<span class="lineNum">     228 </span>            :         int distance = abs(i - j);
<span class="lineNum">     229 </span>            :         if (distance &gt; local_bandwidth) {
<span class="lineNum">     230 </span>            :           local_bandwidth = distance;
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span>            :       }
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span>            :   }
<span class="lineNum">     235 </span>            :   MPI_Allreduce(&amp;local_bandwidth, &amp;bandwidth, 1, MPI_INT, MPI_MAX, communicator);
<span class="lineNum">     236 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">     237 </span>            :   printf(&quot;rank %d: AUTODETECT: bandwidth %d\n&quot;, rank, bandwidth);
<span class="lineNum">     238 </span>            : #endif
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   int max_column    = get_max_column(matrix); 
<span class="lineNum">     242 </span>            :   spike_width       = bandwidth;
<span class="lineNum">     243 </span>            :   ipiv              = new int[partition_height];
<span class="lineNum">     244 </span>            :   
<span class="lineNum">     245 </span>            :   M      = matrix; 
<span class="lineNum">     246 </span>            :   M_size = matrix-&gt;n_nonzeros;  
<span class="lineNum">     247 </span>            :   M_rows = partition_height; 
<span class="lineNum">     248 </span>            :   M_cols = max_column;
<span class="lineNum">     249 </span>            :   
<span class="lineNum">     250 </span>            :   F      = RHS; 
<span class="lineNum">     251 </span>            :   F_rows = partition_height; 
<span class="lineNum">     252 </span>            :   F_cols = RHS_col;
<span class="lineNum">     253 </span>            :   F_size = F_rows * F_cols;
<span class="lineNum">     254 </span>            :   
<span class="lineNum">     255 </span>            :   D_rows = partition_height; 
<span class="lineNum">     256 </span>            :   D_cols = partition_height;
<span class="lineNum">     257 </span>            :   D_size = D_rows * D_cols;
<span class="lineNum">     258 </span>            :   D_is_dense = diagonal_dense;
<span class="lineNum">     259 </span>            :   if (D_is_dense) {
<span class="lineNum">     260 </span>            :     D_dense = new T[D_size];
<span class="lineNum">     261 </span>            :     memset (D_dense, 0, D_size * sizeof(T));
<span class="lineNum">     262 </span>            :   }
<span class="lineNum">     263 </span>            :   
<span class="lineNum">     264 </span>            :   if (rank &lt; last_rank) {
<span class="lineNum">     265 </span>            :     V_rows = partition_height; 
<span class="lineNum">     266 </span>            :     V_cols = spike_width;
<span class="lineNum">     267 </span>            :     V_size = V_rows * V_cols;
<span class="lineNum">     268 </span>            :     V = new T[V_size];
<span class="lineNum">     269 </span>            :     memset (V, 0, V_size * sizeof(T));
<span class="lineNum">     270 </span>            :   }
<span class="lineNum">     271 </span>            :   
<span class="lineNum">     272 </span>            :   if (rank &gt; 0) {
<span class="lineNum">     273 </span>            :     W_rows = partition_height; 
<span class="lineNum">     274 </span>            :     W_cols = spike_width;
<span class="lineNum">     275 </span>            :     W_size = W_rows * W_cols;
<span class="lineNum">     276 </span>            :     W = new T[W_size];
<span class="lineNum">     277 </span>            :     memset (W, 0, W_size * sizeof(T));
<span class="lineNum">     278 </span>            :   }
<span class="lineNum">     279 </span>            :   
<span class="lineNum">     280 </span>            :   
<span class="lineNum">     281 </span>            :   G_rows = partition_height; 
<span class="lineNum">     282 </span>            :   G_cols = RHS_col;
<span class="lineNum">     283 </span>            :   G_size = G_rows * G_cols;
<span class="lineNum">     284 </span>            :   if (has_right_hand_side()) {
<span class="lineNum">     285 </span>            :       G = F;
<span class="lineNum">     286 </span>            :   }
<span class="lineNum">     287 </span>            :   
<span class="lineNum">     288 </span>            :   if (rank == master_rank) {
<span class="lineNum">     289 </span>            :       Sr_rows = 2 * spike_width * num_ranks;
<span class="lineNum">     290 </span>            :       Sr_cols = 2 * spike_width * num_ranks;
<span class="lineNum">     291 </span>            :       Sr_size = (num_ranks - 1) * 4 * spike_width * spike_width + num_ranks
<span class="lineNum">     292 </span>            :                 * 2 * spike_width;
<span class="lineNum">     293 </span>            :       
<span class="lineNum">     294 </span>            :       Gr_rows = num_ranks * 2 * spike_width;
<span class="lineNum">     295 </span>            :       Gr_cols = G_cols;
<span class="lineNum">     296 </span>            :       Gr_size = Gr_cols * Gr_rows;
<span class="lineNum">     297 </span>            :       Gr = new T[Gr_size]; 
<span class="lineNum">     298 </span>            :       memset(Gr, 0, Gr_size * sizeof(T));
<span class="lineNum">     299 </span>            :   }
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">     302 </span>            :   debug_path = SPIKE_DEBUG_PATH;
<span class="lineNum">     303 </span>            : #endif
<span class="lineNum">     304 </span>            :   
<span class="lineNum">     305 </span>            : }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : template &lt;typename T&gt;
<span class="lineNum">     308 </span>            : Spike&lt;T&gt;::~Spike() {
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :   delete[] ipiv;
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : template &lt;typename T&gt;
<span class="lineNum">     316 </span>            : void Spike&lt;T&gt;::solve_full(T* sol) {
<span class="lineNum">     317 </span>            :   X = sol;
<span class="lineNum">     318 </span>            :   preprocess();
<span class="lineNum">     319 </span>            :   postprocess();
<span class="lineNum">     320 </span>            : }
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : template &lt;typename T&gt;
<span class="lineNum">     325 </span>            : void Spike&lt;T&gt;::preprocess() {
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">     328 </span>            :   debug();
<span class="lineNum">     329 </span>            : #endif /* SPIKE_DEBUG */
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     332 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     333 </span>            : #endif
<span class="lineNum">     334 </span>            :   prepare_D();
<span class="lineNum">     335 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     336 </span>            :   printf(&quot;rank %d: preparing D: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     337 </span>            : #endif
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     340 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     341 </span>            : #endif
<span class="lineNum">     342 </span>            :   prepare_sparsity_pattern();
<span class="lineNum">     343 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     344 </span>            :   printf(&quot;rank %d: preparing sparsity pattern: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     345 </span>            : #endif
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     348 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     349 </span>            : #endif
<span class="lineNum">     350 </span>            :   calculate_spikes();
<span class="lineNum">     351 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     352 </span>            :   printf(&quot;rank %d: calculating spikes: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     353 </span>            : #endif
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     356 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     357 </span>            : #endif
<span class="lineNum">     358 </span>            :   calculate_G();
<span class="lineNum">     359 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     360 </span>            :   printf(&quot;rank %d: calculating G: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     361 </span>            : #endif
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :   delete_D();
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     366 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     367 </span>            : #endif
<span class="lineNum">     368 </span>            :   prepare_send_buffer_spikes();
<span class="lineNum">     369 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     370 </span>            :   printf(&quot;rank %d: preparing spike send buffer: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     371 </span>            : #endif
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     374 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     375 </span>            : #endif
<span class="lineNum">     376 </span>            :   distribute_reduced_spikes();
<span class="lineNum">     377 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     378 </span>            :   printf(&quot;rank %d: distribute reduced spikes: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     379 </span>            : #endif
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     382 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     383 </span>            : #endif
<span class="lineNum">     384 </span>            :   prepare_send_buffer_G();
<span class="lineNum">     385 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     386 </span>            :   printf(&quot;rank %d: preparing G send buffer: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     387 </span>            : #endif
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     390 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     391 </span>            : #endif
<span class="lineNum">     392 </span>            :   distribute_reduced_G();
<span class="lineNum">     393 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     394 </span>            :   printf(&quot;rank %d: distribute G: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     395 </span>            : #endif
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : }
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : template &lt;typename T&gt;
<span class="lineNum">     401 </span>            : void Spike&lt;T&gt;::postprocess() {
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     404 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     405 </span>            : #endif
<span class="lineNum">     406 </span>            :   solve_reduced_system();
<span class="lineNum">     407 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     408 </span>            :   printf(&quot;rank %d: solving reduced system: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     409 </span>            : #endif
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     412 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     413 </span>            : #endif
<span class="lineNum">     414 </span>            :   distribute_Xr();
<span class="lineNum">     415 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     416 </span>            :   printf(&quot;rank %d: distributing Xr: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     417 </span>            : #endif
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     420 </span>            :   start_time = get_time(0.0);
<span class="lineNum">     421 </span>            : #endif
<span class="lineNum">     422 </span>            :   expand_reduced_system();
<span class="lineNum">     423 </span>            : #ifdef SPIKE_TIMING
<span class="lineNum">     424 </span>            :   printf(&quot;rank %d: expanding Xr: %f\n&quot;, rank, get_time(start_time));
<span class="lineNum">     425 </span>            : #endif
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            : }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">     431 </span>            : template &lt;typename T&gt;
<span class="lineNum">     432 </span>            : void Spike&lt;T&gt;::debug() {
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   dump_f(F, F_rows, F_cols, &quot;F&quot;);
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : };
<span class="lineNum">     437 </span>            : #endif /* SPIKE_DEBUG */
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : template &lt;typename T&gt;
<span class="lineNum">     442 </span>            : void Spike&lt;T&gt;::prepare_send_buffer_G() {
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   // NOTE: Gr_sendbuffer is constructed in row major format since
<span class="lineNum">     445 </span>            :   // construction of Gr on the master rank happens by vertical concatenation
<span class="lineNum">     446 </span>            :   // (i.e. appending of rows);
<span class="lineNum">     447 </span>            :   
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // 2 PARTITION NOTE:
<span class="lineNum">     450 </span>            :   //      rank1 only needs to send G1t
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   if (has_right_hand_side()) {   
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :     Gr_sendbuffer_rows = G_cols; 
<span class="lineNum">     455 </span>            :     Gr_sendbuffer_cols = 2 * spike_width;
<span class="lineNum">     456 </span>            :     Gr_sendbuffer_size = Gr_sendbuffer_rows * Gr_sendbuffer_cols; 
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :     // Buffer for the reduced system
<span class="lineNum">     459 </span>            :     Gr_sendbuffer = new T[Gr_sendbuffer_size];
<span class="lineNum">     460 </span>            :     
<span class="lineNum">     461 </span>            :     merge_matrix_c(Gr_sendbuffer, Gr_sendbuffer_cols, 0, 0, G,
<span class="lineNum">     462 </span>            :                    G_cols * spike_width, partition_height, spike_width);
<span class="lineNum">     463 </span>            :     merge_matrix_c(Gr_sendbuffer, Gr_sendbuffer_cols, 0, spike_width, 
<span class="lineNum">     464 </span>            :                    &amp;G[partition_height - spike_width], G_cols * spike_width,
<span class="lineNum">     465 </span>            :                    partition_height, spike_width);
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     transpose_dense_matrix(Gr_sendbuffer, Gr_sendbuffer_rows, Gr_sendbuffer_cols);
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :     std::swap(Gr_sendbuffer_rows, Gr_sendbuffer_cols);
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            : template &lt;typename T&gt;
<span class="lineNum">     477 </span>            : void Spike&lt;T&gt;::distribute_reduced_G() {
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :   if (has_right_hand_side()) {
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :     // 2 PARTITION NOTE:
<span class="lineNum">     482 </span>            :     //      rank1 only needs to send G1t
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :     int gr_offset = rank * (Gr_sendbuffer_size);
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     if (rank == master_rank) {
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :       MPI_Win_create(Gr, Gr_size * sizeof(T), sizeof(T), MPI_INFO_NULL,
<span class="lineNum">     489 </span>            :                      comm, &amp;win_Gr);
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     } else {
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :       MPI_Win_create(MPI_BOTTOM, 0, 1, MPI_INFO_NULL, comm,
<span class="lineNum">     494 </span>            :                      &amp;win_Gr);
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :     }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :     // Start fence
<span class="lineNum">     499 </span>            :     MPI_Win_fence(0, win_Gr);
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :     if (has_right_hand_side() &amp;&amp; rank != master_rank) {
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :           MPI_Put(Gr_sendbuffer, Gr_sendbuffer_size, MPI_data_type, master_rank,
<span class="lineNum">     504 </span>            :                    gr_offset, Gr_sendbuffer_size, MPI_data_type, win_Gr);
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     } else if (rank == master_rank) {
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :           memcpy(Gr, Gr_sendbuffer, Gr_sendbuffer_size * sizeof(T));   
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :     // Stop fence
<span class="lineNum">     513 </span>            :     MPI_Win_fence(0, win_Gr);
<span class="lineNum">     514 </span>            :     MPI_Win_free(&amp;win_Gr);
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :     delete[] Gr_sendbuffer;
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     if (rank == master_rank) {
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :       transpose_dense_matrix(Gr, Gr_rows, Gr_cols); 
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :       dump_f(Gr, Gr_rows, Gr_cols, &quot;Gr&quot;);
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :   }
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : }
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : template &lt;typename T&gt;
<span class="lineNum">     531 </span>            : void Spike&lt;T&gt;::prepare_send_buffer_spikes() {
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :   // 2 PARTITION NOTE:
<span class="lineNum">     534 </span>            :   //      rank1 only needs to send Wt
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :   CPX* ones = new T[2 * spike_width];
<span class="lineNum">     537 </span>            :   for (int i = 0; i &lt; 2 * spike_width; ++i) {
<span class="lineNum">     538 </span>            :      ones[i]=T(1);
<span class="lineNum">     539 </span>            :   }
<span class="lineNum">     540 </span>            :   
<span class="lineNum">     541 </span>            :   if (rank == 0 || rank == last_rank) {
<span class="lineNum">     542 </span>            :     Sr_sendbuffer_size = 2 * (spike_width * spike_width + spike_width); 
<span class="lineNum">     543 </span>            :     Sr_sendbuffer_rows = spike_width + 1; 
<span class="lineNum">     544 </span>            :     Sr_sendbuffer_cols = 2 * spike_width;
<span class="lineNum">     545 </span>            :   } else {
<span class="lineNum">     546 </span>            :     Sr_sendbuffer_size = 2 * (2 * spike_width * spike_width + spike_width); 
<span class="lineNum">     547 </span>            :     Sr_sendbuffer_rows = 2 * spike_width + 1; 
<span class="lineNum">     548 </span>            :     Sr_sendbuffer_cols = 2 * spike_width;
<span class="lineNum">     549 </span>            :   }
<span class="lineNum">     550 </span>            :   
<span class="lineNum">     551 </span>            :   Sr_sendbuffer = new T[Sr_sendbuffer_size];
<span class="lineNum">     552 </span>            :   memset(Sr_sendbuffer, 0,Sr_sendbuffer_size * sizeof(T));
<span class="lineNum">     553 </span>            :    
<span class="lineNum">     554 </span>            :   if (rank == 0) {
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, 1, V, 
<span class="lineNum">     557 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     558 </span>            :     
<span class="lineNum">     559 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, spike_width, 1,
<span class="lineNum">     560 </span>            :                    &amp;V[partition_height  - spike_width],
<span class="lineNum">     561 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     562 </span>            :     
<span class="lineNum">     563 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, 0, &amp;ones[0],
<span class="lineNum">     564 </span>            :                    Sr_sendbuffer_cols, Sr_sendbuffer_cols, Sr_sendbuffer_cols);
<span class="lineNum">     565 </span>            :        
<span class="lineNum">     566 </span>            :   } else if (rank == last_rank) {
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, 0, W,
<span class="lineNum">     569 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, spike_width, 0,
<span class="lineNum">     572 </span>            :                    &amp;W[(partition_height - spike_width)],
<span class="lineNum">     573 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, spike_width, &amp;ones[0],
<span class="lineNum">     576 </span>            :                    Sr_sendbuffer_cols, Sr_sendbuffer_cols, Sr_sendbuffer_cols);
<span class="lineNum">     577 </span>            :      
<span class="lineNum">     578 </span>            :   } else {
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, 0, W,
<span class="lineNum">     581 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, spike_width, 0, 
<span class="lineNum">     584 </span>            :                    &amp;W[(partition_height - spike_width)],
<span class="lineNum">     585 </span>            :                    spike_width * spike_width, partition_height, spike_width);     
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, spike_width + 1, V,
<span class="lineNum">     588 </span>            :                    spike_width * spike_width, partition_height, spike_width);    
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, spike_width, spike_width + 1,
<span class="lineNum">     591 </span>            :                    &amp;V[ (partition_height - spike_width)],
<span class="lineNum">     592 </span>            :                    spike_width * spike_width, partition_height, spike_width);
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :     merge_matrix_f(Sr_sendbuffer, Sr_sendbuffer_cols, 0, spike_width, &amp;ones[0],
<span class="lineNum">     595 </span>            :                    Sr_sendbuffer_cols, Sr_sendbuffer_cols, Sr_sendbuffer_cols);   
<span class="lineNum">     596 </span>            :  
<span class="lineNum">     597 </span>            :   }
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :   delete[] ones;
<span class="lineNum">     600 </span>            :  
<span class="lineNum">     601 </span>            : }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : template &lt;typename T&gt;
<span class="lineNum">     604 </span>            : void Spike&lt;T&gt;::prepare_D() {
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :   if (D_is_dense) {
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :     get_dense_from_sparse_f(M, 0, M_rows * rank, M_rows, M_rows * (rank + 1),
<span class="lineNum">     609 </span>            :                             D_dense);
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :     dump_f(D_dense, D_rows, D_cols, &quot;D_dense&quot;);
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     calculate_lu_decomposition(D_dense, D_rows, D_cols);
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :   } else {
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :     D_sparse = get_sparse_from_sparse(M, 0, M_rows * rank, M_rows,
<span class="lineNum">     618 </span>            :                                       M_rows * (rank + 1));
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     dump(D_sparse, &quot;D_sparse&quot;);
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :   }
<span class="lineNum">     623 </span>            : }
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : template &lt;typename T&gt;
<span class="lineNum">     626 </span>            : void Spike&lt;T&gt;::calculate_spikes() {
<span class="lineNum">     627 </span>            :      
<span class="lineNum">     628 </span>            :   if (rank &lt; last_rank) {
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :     if (D_is_dense) {
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :       get_dense_from_sparse_f(M, 0, M_rows * (rank + 1), M_rows,
<span class="lineNum">     633 </span>            :                               M_rows * (rank + 1) + V_cols, V);  
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :       solve_linear_system_dense(D_dense, D_rows, D_cols, V, V_cols);
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     } else {
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :       T* B = new T[V_size];
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :       get_dense_from_sparse_f(M, 0, M_rows * (rank + 1), M_rows,
<span class="lineNum">     642 </span>            :                               M_rows * (rank + 1) + V_cols, B);
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :       solve_linear_system_sparse(D_sparse, B, V_cols, V);
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :       delete[] B;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :     }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :     dump_f(V, V_rows, V_cols, &quot;V&quot;);
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   if (rank &gt; 0) {
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :     if (D_is_dense) {
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            :       get_dense_from_sparse_f(M, 0, M_rows * rank - W_cols, M_rows, M_rows * rank, W);
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :       solve_linear_system_dense(D_dense, D_rows, D_cols, W, W_cols);        
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :     } else {
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :       T* C = new T[W_size];
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :       get_dense_from_sparse_f(M, 0, M_rows * rank - W_cols, M_rows, M_rows * rank, C);
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :       solve_linear_system_sparse(D_sparse, C, W_cols, W);
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :       delete[] C;
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :     dump_f(W, W_rows, W_cols, &quot;W&quot;);
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   }
<span class="lineNum">     676 </span>            : }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : template &lt;typename T&gt;
<span class="lineNum">     679 </span>            : void Spike&lt;T&gt;::calculate_G() {
<span class="lineNum">     680 </span>            :   if (has_right_hand_side()) {
<span class="lineNum">     681 </span>            :     if (D_is_dense) {
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :       solve_linear_system_dense(D_dense, D_rows, D_cols, G, G_cols);   
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :     } else {
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :       T* temp = new T[G_size];
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :       solve_linear_system_sparse(D_sparse, G, G_cols, temp);
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :       // NOTE:
<span class="lineNum">     692 </span>            :       // What we use for G is actually 'sol', which is preallocated memory.
<span class="lineNum">     693 </span>            :       // Thus we don't delete it but swap it with temp instead.  However, if
<span class="lineNum">     694 </span>            :       // the caller assumes that we don't change this, we're in trouble ...
<span class="lineNum">     695 </span>            :       std::swap(G, temp);
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :     }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :     dump_f(G, G_rows, G_cols, &quot;G&quot;);
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :   }
<span class="lineNum">     702 </span>            : }
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : template &lt;typename T&gt;
<span class="lineNum">     705 </span>            : void Spike&lt;T&gt;::delete_D() {
<span class="lineNum">     706 </span>            :   if (D_is_dense) {
<span class="lineNum">     707 </span>            :     delete[] D_dense;
<span class="lineNum">     708 </span>            :   } else {
<span class="lineNum">     709 </span>            :     delete D_sparse;
<span class="lineNum">     710 </span>            :   }
<span class="lineNum">     711 </span>            : }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : template&lt;typename T&gt;
<span class="lineNum">     714 </span>            : void Spike&lt;T&gt;::prepare_sparsity_pattern() {
<span class="lineNum">     715 </span>            :   if (rank == master_rank) {
<span class="lineNum">     716 </span>            :     
<span class="lineNum">     717 </span>            :     int Sr_num_rows = 2 * spike_width * num_ranks;
<span class="lineNum">     718 </span>            :     int Sr_num_nnz  = (4 * spike_width * spike_width + 2 * spike_width) *
<span class="lineNum">     719 </span>            :                       (num_ranks - 2) + 4 * (spike_width * spike_width + 
<span class="lineNum">     720 </span>            :                       spike_width);
<span class="lineNum">     721 </span>            :     
<span class="lineNum">     722 </span>            :     Sr = new TCSR&lt;T&gt;(Sr_num_rows, Sr_num_nnz, 0);
<span class="lineNum">     723 </span>            :     
<span class="lineNum">     724 </span>            :     int findx = Sr-&gt;findx;
<span class="lineNum">     725 </span>            :     int num_partitions = num_ranks;
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :     // Construct sparsity pattern
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     // edge_i and index_i
<span class="lineNum">     731 </span>            :     Sr-&gt;edge_i[0] = 0;
<span class="lineNum">     732 </span>            :     for (int i = 1; i &lt; Sr_rows + 1; ++i) {
<span class="lineNum">     733 </span>            :       if (i &lt;= 2 * spike_width || i &gt; (num_partitions - 1) * 2 * spike_width) {
<span class="lineNum">     734 </span>            :         Sr-&gt;edge_i[i] = Sr-&gt;edge_i[i-1] + 1 + spike_width;
<span class="lineNum">     735 </span>            :       } else {
<span class="lineNum">     736 </span>            :         Sr-&gt;edge_i[i] = Sr-&gt;edge_i[i-1] + 1 + 2 * spike_width;
<span class="lineNum">     737 </span>            :       }
<span class="lineNum">     738 </span>            :       Sr-&gt;index_i[i - 1] = Sr-&gt;edge_i[i] - Sr-&gt;edge_i[i - 1];
<span class="lineNum">     739 </span>            :     }
<span class="lineNum">     740 </span>            :     Sr-&gt;get_row_edge();
<span class="lineNum">     741 </span>            :     Sr-&gt;get_diag_pos();
<span class="lineNum">     742 </span>            :     
<span class="lineNum">     743 </span>            :     int index = 0;
<span class="lineNum">     744 </span>            :     
<span class="lineNum">     745 </span>            :     // First block row only contains |Vr|
<span class="lineNum">     746 </span>            :     int Vr_start = 2 * spike_width;
<span class="lineNum">     747 </span>            :     for (int matrix_row = 0; matrix_row &lt; 2 * spike_width; ++matrix_row) {
<span class="lineNum">     748 </span>            :       Sr-&gt;index_j[index++] = matrix_row + findx;    // diagonal elements
<span class="lineNum">     749 </span>            :       for (int Vr_column = 0; Vr_column &lt; spike_width; ++Vr_column) {
<span class="lineNum">     750 </span>            :         Sr-&gt;index_j[index++] = Vr_start + Vr_column + findx; // V0t and V0b
<span class="lineNum">     751 </span>            :       }
<span class="lineNum">     752 </span>            :     }
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :     // All other except the last contain |Wr|1|Vr|
<span class="lineNum">     755 </span>            :     for (int block_row = 1; block_row &lt; num_partitions-1; ++block_row) {
<span class="lineNum">     756 </span>            :       int Wr_start = (2 * (block_row - 1) + 1) * spike_width;
<span class="lineNum">     757 </span>            :       int Vr_start = (2 * (block_row + 1)) * spike_width;
<span class="lineNum">     758 </span>            :       for (int matrix_row = 2 * spike_width * block_row;
<span class="lineNum">     759 </span>            :            matrix_row &lt; 2 * spike_width * (block_row + 1); ++matrix_row) {
<span class="lineNum">     760 </span>            :         // Wr
<span class="lineNum">     761 </span>            :         for (int Wr_column = 0; Wr_column &lt; spike_width; ++Wr_column) {
<span class="lineNum">     762 </span>            :           Sr-&gt;index_j[index++] = Wr_start + Wr_column + findx;
<span class="lineNum">     763 </span>            :         }
<span class="lineNum">     764 </span>            :         // 1
<span class="lineNum">     765 </span>            :         Sr-&gt;index_j[index++] = matrix_row + findx;
<span class="lineNum">     766 </span>            :         // Vr
<span class="lineNum">     767 </span>            :         for (int Vr_column = 0; Vr_column &lt; spike_width; ++Vr_column) {
<span class="lineNum">     768 </span>            :           Sr-&gt;index_j[index++] = Vr_start + Vr_column + findx;
<span class="lineNum">     769 </span>            :         }
<span class="lineNum">     770 </span>            :       }
<span class="lineNum">     771 </span>            :     }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :     // Last block only contains |Wr|
<span class="lineNum">     774 </span>            :     int Wr_start = (2 * (num_partitions - 2) + 1) * spike_width;
<span class="lineNum">     775 </span>            :     for (int matrix_row = 2 * spike_width * (num_partitions - 1);
<span class="lineNum">     776 </span>            :          matrix_row &lt; 2 * spike_width * num_partitions; ++matrix_row) {
<span class="lineNum">     777 </span>            :       for (int Wr_column = 0; Wr_column &lt; spike_width; ++Wr_column) {
<span class="lineNum">     778 </span>            :         Sr-&gt;index_j[index++]=Wr_start + Wr_column + findx;
<span class="lineNum">     779 </span>            :       }
<span class="lineNum">     780 </span>            :       // 1
<span class="lineNum">     781 </span>            :       Sr-&gt;index_j[index++] = matrix_row + findx;
<span class="lineNum">     782 </span>            :     }
<span class="lineNum">     783 </span>            :   }
<span class="lineNum">     784 </span>            : }
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : template &lt;typename T&gt;
<span class="lineNum">     787 </span>            : void Spike&lt;T&gt;::distribute_reduced_spikes() {
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :   // 2 PARTITION NOTE:
<span class="lineNum">     790 </span>            :   //      rank1 only needs to send Wt
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   // NOTE: since Sr is constructed by adding rows, we change the memory layout
<span class="lineNum">     793 </span>            :   // to row major
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :   transpose_dense_matrix(Sr_sendbuffer, Sr_sendbuffer_rows, Sr_sendbuffer_cols);
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :   int Sr_offset;
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :   if (rank == master_rank) {
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     MPI_Win_create(Sr-&gt;nnz, Sr_size * sizeof(T), sizeof(T), MPI_INFO_NULL,
<span class="lineNum">     802 </span>            :                    comm, &amp;win_Sr);
<span class="lineNum">     803 </span>            :     Sr_offset = 0;
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :   } else {
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :     MPI_Win_create(MPI_BOTTOM, 0, 1, MPI_INFO_NULL, comm, &amp;win_Sr);
<span class="lineNum">     808 </span>            :     Sr_offset = 2 * (spike_width * spike_width + spike_width) + 2 * (rank - 1) *
<span class="lineNum">     809 </span>            :                 (2 * spike_width * spike_width + spike_width);
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :   }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   // Start fence
<span class="lineNum">     814 </span>            :   MPI_Win_fence(0, win_Sr);
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :   if (rank != master_rank) {   
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :     MPI_Put(Sr_sendbuffer, Sr_sendbuffer_size, MPI_data_type, master_rank,
<span class="lineNum">     819 </span>            :             Sr_offset, Sr_sendbuffer_size, MPI_data_type, win_Sr);
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :   } else if (rank == master_rank) {
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     memcpy(Sr-&gt;nnz, Sr_sendbuffer, Sr_sendbuffer_size * sizeof(T));  
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :   }   
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :   // Stop fence
<span class="lineNum">     828 </span>            :   MPI_Win_fence(0, win_Sr);
<span class="lineNum">     829 </span>            :   MPI_Win_free(&amp;win_Sr);
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :   delete[] Sr_sendbuffer;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   if (rank == master_rank) {
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     dump(Sr, &quot;Sr&quot;);
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :   }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            : template &lt;typename T&gt;
<span class="lineNum">     842 </span>            : void Spike&lt;T&gt;::distribute_Xr() {
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   // NOTE: Xr is sent in row major format since construction of Xr on the 
<span class="lineNum">     845 </span>            :   // other ranks happens by vertical concatenation (i.e. appending of rows);
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :   // Let 0 denote the index of the previous rank, 1 the index of the current
<span class="lineNum">     848 </span>            :   // rank and 2 the index of the next rank. Then, after distribute_Xr(), each
<span class="lineNum">     849 </span>            :   // rank other than the first and last have
<span class="lineNum">     850 </span>            :   //
<span class="lineNum">     851 </span>            :   //          Xr = [X0b;
<span class="lineNum">     852 </span>            :   //                X1t;
<span class="lineNum">     853 </span>            :   //                X1b;
<span class="lineNum">     854 </span>            :   //                X2t;]
<span class="lineNum">     855 </span>            :   //
<span class="lineNum">     856 </span>            :   // while the first and last rank have
<span class="lineNum">     857 </span>            :   //
<span class="lineNum">     858 </span>            :   //          Xr = [X1t;
<span class="lineNum">     859 </span>            :   //                X1b;
<span class="lineNum">     860 </span>            :   //                X2t;
<span class="lineNum">     861 </span>            :   //                 * ;]
<span class="lineNum">     862 </span>            :   //             and
<span class="lineNum">     863 </span>            :   //          Xr = [X0b;
<span class="lineNum">     864 </span>            :   //                X1t;
<span class="lineNum">     865 </span>            :   //                X1b;
<span class="lineNum">     866 </span>            :   //                 * ;]
<span class="lineNum">     867 </span>            :   //
<span class="lineNum">     868 </span>            :   // respectively. All matrices are in column major format. Concatenation is
<span class="lineNum">     869 </span>            :   // according to matlab, i.e. vertical in the above notation.
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   int Xr_offset;
<span class="lineNum">     872 </span>            :   
<span class="lineNum">     873 </span>            :   if (rank == master_rank) {
<span class="lineNum">     874 </span>            :     transpose_dense_matrix(Xr, Xr_rows, Xr_cols); 
<span class="lineNum">     875 </span>            :     MPI_Win_create(Xr, Xr_size * sizeof(T), sizeof(T), 
<span class="lineNum">     876 </span>            :                    MPI_INFO_NULL, comm, &amp;win_Xr);  
<span class="lineNum">     877 </span>            :   } else {
<span class="lineNum">     878 </span>            :     MPI_Win_create(MPI_BOTTOM, 0, 1, MPI_INFO_NULL, comm,
<span class="lineNum">     879 </span>            :                    &amp;win_Xr);
<span class="lineNum">     880 </span>            :   }
<span class="lineNum">     881 </span>            :  
<span class="lineNum">     882 </span>            :   if (rank == 0 || rank == last_rank) {
<span class="lineNum">     883 </span>            :     Xr_local_cols = F_cols; 
<span class="lineNum">     884 </span>            :     Xr_local_rows = 3 * spike_width; 
<span class="lineNum">     885 </span>            :     Xr_local_size = Xr_local_cols * Xr_local_rows;
<span class="lineNum">     886 </span>            :     Xr_offset  = 0;
<span class="lineNum">     887 </span>            :   } else {
<span class="lineNum">     888 </span>            :     Xr_local_cols = F_cols; 
<span class="lineNum">     889 </span>            :     Xr_local_rows = 4 * spike_width; 
<span class="lineNum">     890 </span>            :     Xr_local_size = Xr_local_cols * Xr_local_rows;
<span class="lineNum">     891 </span>            :   }
<span class="lineNum">     892 </span>            :   
<span class="lineNum">     893 </span>            :   if (rank &gt; 0) {
<span class="lineNum">     894 </span>            :     Xr_offset = spike_width * F_cols + (rank - 1) * (2 * spike_width * F_cols); 
<span class="lineNum">     895 </span>            :   }
<span class="lineNum">     896 </span>            :   
<span class="lineNum">     897 </span>            :   Xr_local = new CPX[Xr_local_size];
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :   // Start fence
<span class="lineNum">     901 </span>            :   MPI_Win_fence(0, win_Xr);
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :   if (rank != master_rank) {
<span class="lineNum">     904 </span>            :     MPI_Get(Xr_local, Xr_local_size, MPI_data_type, master_rank, Xr_offset,
<span class="lineNum">     905 </span>            :             Xr_local_size, MPI_data_type, win_Xr);
<span class="lineNum">     906 </span>            :   }
<span class="lineNum">     907 </span>            :   if (rank == master_rank) {
<span class="lineNum">     908 </span>            :     memcpy(Xr_local, Xr + Xr_offset, Xr_local_size * sizeof(T));
<span class="lineNum">     909 </span>            :   }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            :   // Stop fence
<span class="lineNum">     912 </span>            :   MPI_Win_fence(0, win_Xr);
<span class="lineNum">     913 </span>            :   MPI_Win_free(&amp;win_Xr);
<span class="lineNum">     914 </span>            :   
<span class="lineNum">     915 </span>            :   transpose_dense_matrix(Xr_local, Xr_local_rows, Xr_local_cols);
<span class="lineNum">     916 </span>            :   
<span class="lineNum">     917 </span>            :   if (rank == master_rank) {  
<span class="lineNum">     918 </span>            :     delete[] Xr;  
<span class="lineNum">     919 </span>            :   }
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :   dump_f(Xr_local, Xr_local_rows, Xr_local_cols, &quot;Xr_local&quot;);
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : /** \brief Solve the reduced sparse system
<span class="lineNum">     929 </span>            :  */
<span class="lineNum">     930 </span>            : template&lt;typename T&gt;
<span class="lineNum">     931 </span>            : void Spike&lt;T&gt;::solve_reduced_system() {
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            :   // 2 PARTITION NOTE:
<span class="lineNum">     934 </span>            :   //  
<span class="lineNum">     935 </span>            :   //  Faster way:
<span class="lineNum">     936 </span>            :   //    E   = unity(bandwidth) - Wt*Vb;
<span class="lineNum">     937 </span>            :   //    X1t = E\(G1t - Wt * G0b);
<span class="lineNum">     938 </span>            :   //    X0b = G0b - Vb * X1t;
<span class="lineNum">     939 </span>            :   //
<span class="lineNum">     940 </span>            :   //  Then send only X0b and X1t to rank1
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   if (rank == master_rank) {
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :     Xr_rows = Gr_cols;
<span class="lineNum">     945 </span>            :     Xr_cols = Gr_rows;
<span class="lineNum">     946 </span>            :     Xr_size = Xr_cols * Xr_rows;
<span class="lineNum">     947 </span>            :     Xr = new T[Xr_size];
<span class="lineNum">     948 </span>            :     memset (Xr, 0, Xr_size * sizeof(T));
<span class="lineNum">     949 </span>            :     
<span class="lineNum">     950 </span>            :     solve_linear_system_sparse(Sr, Gr, Gr_cols, Xr);
<span class="lineNum">     951 </span>            :     
<span class="lineNum">     952 </span>            :     delete[] Gr;
<span class="lineNum">     953 </span>            :     delete Sr;
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :     dump_f(Xr, Xr_rows, Xr_cols, &quot;Xr&quot;);
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :   }
<span class="lineNum">     958 </span>            : }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            : /** \brief Calculation of the final result by using Xr 
<span class="lineNum">     962 </span>            :  */
<span class="lineNum">     963 </span>            : template &lt;typename T&gt;
<span class="lineNum">     964 </span>            : void Spike&lt;T&gt;::expand_reduced_system() {
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :   X_rows = partition_height; 
<span class="lineNum">     967 </span>            :   X_cols = F_cols;
<span class="lineNum">     968 </span>            :   X_size = X_rows * X_cols;
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   if (num_ranks == 2) {
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :     if (rank == master_rank) {
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :       // X0u = G0u - V0u * X1t    % u -&gt; [1:end-bw,:]
<span class="lineNum">     975 </span>            :       xLACPY('A', G_rows - spike_width, G_cols, G, G_rows, X, X_rows);
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :       dump_f(X, X_rows, X_cols, &quot;G0u&quot;);
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :       int X1t_offset = 2 * spike_width;
<span class="lineNum">     980 </span>            :       xGEMM('N', 'N', V_rows - spike_width, Xr_local_cols, V_cols, T(-1.0), V,
<span class="lineNum">     981 </span>            :             V_rows, &amp;Xr_local[X1t_offset], Xr_local_rows, T(1.0), X, X_rows);
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :       dump_f(X, X_rows, X_cols, &quot;X0u&quot;);
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :       // Xb = X0b                % b -&gt; [end-bw+1:end,:]
<span class="lineNum">     986 </span>            :       int X0b_offset = spike_width;
<span class="lineNum">     987 </span>            :       int Xb_offset = X_rows - spike_width;
<span class="lineNum">     988 </span>            :       xLACPY('A', spike_width, Xr_local_cols, &amp;Xr_local[X0b_offset],
<span class="lineNum">     989 </span>            :              Xr_local_rows, &amp;X[Xb_offset], X_rows);
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :     } else if (rank == last_rank) {
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :       int Gl_offset = spike_width;
<span class="lineNum">     994 </span>            :       int Xl_offset = spike_width;
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :       // X1l = G1l - W1l * X0b    % l -&gt; [bw+1:end,:]
<span class="lineNum">     997 </span>            :       xLACPY('A', G_rows - spike_width, G_cols, &amp;G[Gl_offset], G_rows,
<span class="lineNum">     998 </span>            :              &amp;X[Xl_offset], X_rows);
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :       dump_f(X, X_rows, X_cols, &quot;G1l&quot;);
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :       int Wl_offset = spike_width;
<span class="lineNum">    1003 </span>            :       xGEMM('N', 'N', W_rows - spike_width, Xr_local_cols, W_cols, T(-1.0),
<span class="lineNum">    1004 </span>            :             &amp;W[Wl_offset], W_rows, Xr_local, Xr_local_rows, T(1.0),
<span class="lineNum">    1005 </span>            :             &amp;X[Xl_offset], X_rows);
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :       dump_f(X, X_rows, X_cols, &quot;X1l&quot;);
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :       // Xt = X1t                % t -&gt; [1:bw,:]
<span class="lineNum">    1010 </span>            :       int X1t_offset = spike_width;
<span class="lineNum">    1011 </span>            :       xLACPY('A', spike_width, Xr_local_cols, &amp;Xr_local[X1t_offset],
<span class="lineNum">    1012 </span>            :              Xr_local_rows, X, X_rows);
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :   } else {
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :     // TODO: this is probably not fully working yet
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            :     // Prepare GNprime
<span class="lineNum">    1022 </span>            :     int middle_height = partition_height - 2 * spike_width;
<span class="lineNum">    1023 </span>            :     int middle_size = middle_height * spike_width;
<span class="lineNum">    1024 </span>            :     
<span class="lineNum">    1025 </span>            :     int GNprime_prefactor;
<span class="lineNum">    1026 </span>            :     T* C;
<span class="lineNum">    1027 </span>            :     bool allocated_C = false;
<span class="lineNum">    1028 </span>            :    
<span class="lineNum">    1029 </span>            :     if (has_right_hand_side()) {
<span class="lineNum">    1030 </span>            :       GNprime_prefactor = 1;
<span class="lineNum">    1031 </span>            :       C = &amp;G[spike_width];
<span class="lineNum">    1032 </span>            :     } else {
<span class="lineNum">    1033 </span>            :       C = new T[middle_size];
<span class="lineNum">    1034 </span>            :       allocated_C = true;
<span class="lineNum">    1035 </span>            :       memset(C, 0, middle_size * sizeof(T)); 
<span class="lineNum">    1036 </span>            :       GNprime_prefactor = 0;   // so we don't need to initialize
<span class="lineNum">    1037 </span>            :     }
<span class="lineNum">    1038 </span>            :     
<span class="lineNum">    1039 </span>            :     if (rank == 0) {
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :         int m = partition_height - 2 * spike_width;
<span class="lineNum">    1042 </span>            :         int n = G_cols;
<span class="lineNum">    1043 </span>            :         int k = spike_width;
<span class="lineNum">    1044 </span>            :          
<span class="lineNum">    1045 </span>            :         T* A = &amp;V[spike_width];
<span class="lineNum">    1046 </span>            :         int lda = partition_height;
<span class="lineNum">    1047 </span>            :            
<span class="lineNum">    1048 </span>            :         T* B = &amp;Xr_local[2 * spike_width];
<span class="lineNum">    1049 </span>            :         int ldb = Xr_local_rows;  
<span class="lineNum">    1050 </span>            :        
<span class="lineNum">    1051 </span>            :         int ldc = G_rows;
<span class="lineNum">    1052 </span>            :           
<span class="lineNum">    1053 </span>            :         xGEMM('N', 'N', m, k, n, T(-1.0), A, lda, B,ldb, T(GNprime_prefactor), C, ldc);
<span class="lineNum">    1054 </span>            :          
<span class="lineNum">    1055 </span>            :         merge_matrix_c(X, partition_height, 0, 0, Xr_local,
<span class="lineNum">    1056 </span>            :                        F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1057 </span>            :         merge_matrix_c(X, partition_height, 0, spike_width, C,
<span class="lineNum">    1058 </span>            :                        F_cols * middle_height, partition_height, middle_height);
<span class="lineNum">    1059 </span>            :         merge_matrix_c(X, partition_height, 0, spike_width + m, &amp;Xr_local[spike_width],
<span class="lineNum">    1060 </span>            :                        F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :     } else if (rank == last_rank) {
<span class="lineNum">    1063 </span>            :        
<span class="lineNum">    1064 </span>            :         int m = partition_height - 2 * spike_width;
<span class="lineNum">    1065 </span>            :         int n = G_cols;
<span class="lineNum">    1066 </span>            :         int k = spike_width;
<span class="lineNum">    1067 </span>            :         
<span class="lineNum">    1068 </span>            :       
<span class="lineNum">    1069 </span>            :         T* A = &amp;W[spike_width];
<span class="lineNum">    1070 </span>            :         int lda = partition_height;
<span class="lineNum">    1071 </span>            :            
<span class="lineNum">    1072 </span>            :         T* B = &amp;Xr_local[0];
<span class="lineNum">    1073 </span>            :         
<span class="lineNum">    1074 </span>            :         int ldb = Xr_local_rows;
<span class="lineNum">    1075 </span>            :         
<span class="lineNum">    1076 </span>            :         int ldc = G_rows;
<span class="lineNum">    1077 </span>            :           
<span class="lineNum">    1078 </span>            :         xGEMM('N', 'N', m, k, n, T(-1.0), A, lda, B,ldb, T(GNprime_prefactor), C, ldc);
<span class="lineNum">    1079 </span>            :          
<span class="lineNum">    1080 </span>            :         merge_matrix_c(X, partition_height, 0, 0, &amp;Xr_local[spike_width],
<span class="lineNum">    1081 </span>            :                        F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1082 </span>            :         merge_matrix_c(X, partition_height, 0, spike_width, C,
<span class="lineNum">    1083 </span>            :                        F_cols * middle_height, partition_height, middle_height);
<span class="lineNum">    1084 </span>            :         merge_matrix_c(X, partition_height, 0, spike_width + m, &amp;Xr_local[2 * spike_width],
<span class="lineNum">    1085 </span>            :                        F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :     } else {
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :       int m = partition_height - 2 * spike_width;
<span class="lineNum">    1090 </span>            :       int n = G_cols;
<span class="lineNum">    1091 </span>            :       int k = spike_width;
<span class="lineNum">    1092 </span>            :     
<span class="lineNum">    1093 </span>            :       T* A = &amp;W[spike_width];
<span class="lineNum">    1094 </span>            :       int lda = partition_height;
<span class="lineNum">    1095 </span>            :          
<span class="lineNum">    1096 </span>            :       T* B = &amp;Xr_local[0];
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            :       int ldb = Xr_local_rows;
<span class="lineNum">    1099 </span>            :       
<span class="lineNum">    1100 </span>            :       int ldc = G_rows;
<span class="lineNum">    1101 </span>            :         
<span class="lineNum">    1102 </span>            :       xGEMM('N', 'N', m, k, n, T(-1.0), A, lda, B,ldb, T(GNprime_prefactor), C, ldc); 
<span class="lineNum">    1103 </span>            :       
<span class="lineNum">    1104 </span>            :       A = &amp;V[spike_width];
<span class="lineNum">    1105 </span>            :       B = &amp;Xr_local[3 * spike_width];
<span class="lineNum">    1106 </span>            :       
<span class="lineNum">    1107 </span>            :       xGEMM('N', 'N', m, k, n, T(-1.0), A, lda, B,ldb, T(1), C, ldc); 
<span class="lineNum">    1108 </span>            :       
<span class="lineNum">    1109 </span>            :       merge_matrix_c(X, partition_height, 0, 0, &amp;Xr_local[spike_width],
<span class="lineNum">    1110 </span>            :                      F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1111 </span>            :       merge_matrix_c(X, partition_height, 0, spike_width, C,
<span class="lineNum">    1112 </span>            :                      F_cols * middle_height, partition_height, middle_height);
<span class="lineNum">    1113 </span>            :       merge_matrix_c(X, partition_height, 0, spike_width + m, &amp;Xr_local[2 * spike_width],
<span class="lineNum">    1114 </span>            :                      F_cols * spike_width, Xr_local_rows, spike_width);
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            :     }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :     if (allocated_C) {
<span class="lineNum">    1119 </span>            :       delete[] C;
<span class="lineNum">    1120 </span>            :     }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            :   if (rank != last_rank) {
<span class="lineNum">    1125 </span>            :     delete[] V;
<span class="lineNum">    1126 </span>            :   }
<span class="lineNum">    1127 </span>            :   if (rank != master_rank) {
<span class="lineNum">    1128 </span>            :     delete[] W;
<span class="lineNum">    1129 </span>            :   }
<span class="lineNum">    1130 </span>            :   delete[] Xr_local;
<span class="lineNum">    1131 </span>            :   delete[] G;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span>            :   dump_f(X, X_rows, X_cols, &quot;X&quot;);
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            : }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            : /****************************************************************************
<span class="lineNum">    1140 </span>            :  * General routines
<span class="lineNum">    1141 </span>            :  ***************************************************************************/
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : /** \brief            Extracts a subblock of a sparse matrix by specifying
<span class="lineNum">    1144 </span>            :  *                    the corner indices storing it as dense matrix in C/C++
<span class="lineNum">    1145 </span>            :  *                    convention. It assumes that matrix_out is initialized as
<span class="lineNum">    1146 </span>            :  *                    all zero.
<span class="lineNum">    1147 </span>            :  *
<span class="lineNum">    1148 </span>            :  *  \param[in]        matrix_in
<span class="lineNum">    1149 </span>            :  *                    The CSR matrix to extract the subblock from.
<span class="lineNum">    1150 </span>            :  *
<span class="lineNum">    1151 </span>            :  *  \param[in]        start_row
<span class="lineNum">    1152 </span>            :  *                    Row to start extraction (included, C-numbering).
<span class="lineNum">    1153 </span>            :  *
<span class="lineNum">    1154 </span>            :  *  \param[in]        start_col
<span class="lineNum">    1155 </span>            :  *                    Colum to start extraction (included, C-numbering).
<span class="lineNum">    1156 </span>            :  *
<span class="lineNum">    1157 </span>            :  *  \param[in]        end_row
<span class="lineNum">    1158 </span>            :  *                    Row to stop extraction (excluded, C-numbering).
<span class="lineNum">    1159 </span>            :  *
<span class="lineNum">    1160 </span>            :  *  \param[in]        end_col
<span class="lineNum">    1161 </span>            :  *                    Column to stop extraction (excluded, C-numbering).
<span class="lineNum">    1162 </span>            :  *
<span class="lineNum">    1163 </span>            :  *  \param[out]       matrix_out
<span class="lineNum">    1164 </span>            :  *                    Zero initialized array to contain the subblock.
<span class="lineNum">    1165 </span>            :  */
<span class="lineNum">    1166 </span>            : template&lt;typename T&gt;
<span class="lineNum">    1167 </span>            : void Spike&lt;T&gt;::get_dense_from_sparse_c(TCSR&lt;T&gt;* matrix_in, int start_row, 
<span class="lineNum">    1168 </span>            :                                        int start_col, int end_row, int end_col,
<span class="lineNum">    1169 </span>            :                                        T* matrix_out) {
<span class="lineNum">    1170 </span>            :     int row = end_row - start_row ;
<span class="lineNum">    1171 </span>            :     int column = end_col - start_col;
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :     int findx = matrix_in-&gt;findx; 
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            :     for (int i=start_row; i &lt; end_row ; ++i) {
<span class="lineNum">    1176 </span>            :         for (int j = matrix_in-&gt;edge_i[i]; j &lt; matrix_in-&gt;edge_i[i + 1]; ++j) {
<span class="lineNum">    1177 </span>            :             int indx = matrix_in-&gt;index_j[j];
<span class="lineNum">    1178 </span>            :             if (indx &lt; start_col) continue;
<span class="lineNum">    1179 </span>            :             if (indx &gt;= end_col)  break;
<span class="lineNum">    1180 </span>            :             matrix_out[(i-start_row) * (column) + (indx-start_col)] = 
<span class="lineNum">    1181 </span>            :                 matrix_in-&gt;nnz[j];
<span class="lineNum">    1182 </span>            :         }
<span class="lineNum">    1183 </span>            :     }
<span class="lineNum">    1184 </span>            : }
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            : /** \brief Extracts a subblock of a sparse matrix by specifying the corner
<span class="lineNum">    1187 </span>            :  *         indices storing it as dense matrix in Fortran convention. It assumes 
<span class="lineNum">    1188 </span>            :  *         that matrix_out is initialized as all zero.
<span class="lineNum">    1189 </span>            :  *
<span class="lineNum">    1190 </span>            :  * \param[in] matrix_in   The CSR matrix to extract the subblock from.
<span class="lineNum">    1191 </span>            :  *
<span class="lineNum">    1192 </span>            :  * \param[in] start_row   Row to start extraction (included, C-numbering).
<span class="lineNum">    1193 </span>            :  *
<span class="lineNum">    1194 </span>            :  * \param[in] start_col   Colum to start extraction (included, C-numbering).
<span class="lineNum">    1195 </span>            :  *
<span class="lineNum">    1196 </span>            :  * \param[in] end_row     Row to stop extraction (excluded, C-numbering).
<span class="lineNum">    1197 </span>            :  *
<span class="lineNum">    1198 </span>            :  * \param[in] end_col     Column to stop extraction (excluded, C-numbering).
<span class="lineNum">    1199 </span>            :  *
<span class="lineNum">    1200 </span>            :  * \param[out] matrix_out Zero initialized array to contain the subblock.
<span class="lineNum">    1201 </span>            :  */
<span class="lineNum">    1202 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1203 </span>            : void Spike&lt;T&gt;::get_dense_from_sparse_f(TCSR&lt;T&gt;* matrix_in, int start_row,
<span class="lineNum">    1204 </span>            :                                        int start_col, int end_row, int end_col,
<span class="lineNum">    1205 </span>            :                                        T* matrix_out) {
<span class="lineNum">    1206 </span>            :   int findx = matrix_in-&gt;findx; 
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :   int rows_out = end_row - start_row;
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span>            :   for (int row_in = start_row; row_in &lt; end_row; ++row_in) {
<span class="lineNum">    1211 </span>            :     for (int index = matrix_in-&gt;edge_i[row_in] - findx;
<span class="lineNum">    1212 </span>            :          index &lt; matrix_in-&gt;edge_i[row_in + 1] - findx; ++index) {
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            :       int col_in = matrix_in-&gt;index_j[index] - findx;
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :       if (col_in &lt; start_col) {
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :         continue;
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            :       } else if (col_in &lt; end_col) {
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :         int col_out   = col_in - start_col;
<span class="lineNum">    1223 </span>            :         int row_out   = row_in - start_row;
<span class="lineNum">    1224 </span>            :         int array_pos = col_out * rows_out + row_out;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :         matrix_out[array_pos] = matrix_in-&gt;nnz[index];
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            :       } else {
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            :         break;
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            :       }
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span>            :   }
<span class="lineNum">    1235 </span>            : }
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            : /** \brief Extracts a subblock of a sparse matrix by specifying the corner
<span class="lineNum">    1238 </span>            :  *         indices and returns the result in CSR format.
<span class="lineNum">    1239 </span>            :  *
<span class="lineNum">    1240 </span>            :  * \param[in] matrix_in   The CSR matrix to extract the subblock from.
<span class="lineNum">    1241 </span>            :  *
<span class="lineNum">    1242 </span>            :  * \param[in] start_row   Row to start extraction (included, C-numbering).
<span class="lineNum">    1243 </span>            :  *
<span class="lineNum">    1244 </span>            :  * \param[in] start_col   Colum to start extraction (included, C-numbering).
<span class="lineNum">    1245 </span>            :  *
<span class="lineNum">    1246 </span>            :  * \param[in] end_row     Row to stop extraction (excluded, C-numbering).
<span class="lineNum">    1247 </span>            :  *
<span class="lineNum">    1248 </span>            :  * \param[in] end_col     Column to stop extraction (excluded, C-numbering).
<span class="lineNum">    1249 </span>            :  */
<span class="lineNum">    1250 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1251 </span>            : TCSR&lt;T&gt;* Spike&lt;T&gt;::get_sparse_from_sparse(TCSR&lt;T&gt;* matrix_in, int start_row,
<span class="lineNum">    1252 </span>            :                                           int start_col, int end_row,
<span class="lineNum">    1253 </span>            :                                           int end_col) {
<span class="lineNum">    1254 </span>            :   T*   nnz_in     = matrix_in-&gt;nnz;
<span class="lineNum">    1255 </span>            :   int* edge_i_in  = matrix_in-&gt;edge_i;
<span class="lineNum">    1256 </span>            :   int* index_j_in = matrix_in-&gt;index_j;
<span class="lineNum">    1257 </span>            :   int  findx      = matrix_in-&gt;findx;
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :   // Count non-zeros
<span class="lineNum">    1260 </span>            :   int nnz_count = 0;
<span class="lineNum">    1261 </span>            :   int start_index = edge_i_in[start_row] - findx;
<span class="lineNum">    1262 </span>            :   int stop_index  = edge_i_in[end_row] - findx;
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            :   for (int index = start_index; index &lt; stop_index; ++index) {
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     int col = index_j_in[index] - findx;
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            :     if ((col &gt; start_col - 1) &amp;&amp; (col &lt; end_col)) {
<span class="lineNum">    1269 </span>            :       ++nnz_count;
<span class="lineNum">    1270 </span>            :     }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            :   }
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            :   // Create new CSR matrix
<span class="lineNum">    1275 </span>            :   int rows = end_row - start_row;
<span class="lineNum">    1276 </span>            :   TCSR&lt;T&gt;* matrix_out = new TCSR&lt;T&gt;(rows, nnz_count, findx);
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :   T*   nnz_out     = matrix_out-&gt;nnz;
<span class="lineNum">    1279 </span>            :   int* edge_i_out  = matrix_out-&gt;edge_i;
<span class="lineNum">    1280 </span>            :   int* index_j_out = matrix_out-&gt;index_j;
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span>            :   // Copy data
<span class="lineNum">    1283 </span>            :   int out_index = 0;
<span class="lineNum">    1284 </span>            :   for (int in_row = start_row; in_row &lt; end_row + 1; ++in_row) {
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            :     int out_row = in_row - start_row;
<span class="lineNum">    1287 </span>            :     edge_i_out[out_row] = out_index + findx;
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span>            :     for (int in_index = edge_i_in[in_row] - findx;
<span class="lineNum">    1290 </span>            :          in_index &lt; edge_i_in[in_row + 1] - findx; 
<span class="lineNum">    1291 </span>            :          ++in_index) {
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :       int in_col = index_j_in[in_index] - findx;
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :       if (in_col &lt; start_col) {
<span class="lineNum">    1296 </span>            :         continue;
<span class="lineNum">    1297 </span>            :       } else if (in_col &lt; end_col) {
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            :         T   out_val = nnz_in[in_index];
<span class="lineNum">    1300 </span>            :         int out_col = in_col - start_col;
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            :         nnz_out[out_index]     = out_val;
<span class="lineNum">    1303 </span>            :         index_j_out[out_index] = out_col + findx;
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :         ++out_index;
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :       } else {
<span class="lineNum">    1308 </span>            :         break;
<span class="lineNum">    1309 </span>            :       }
<span class="lineNum">    1310 </span>            :     }
<span class="lineNum">    1311 </span>            :   }
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :   // Construct index_i (# elements per line)
<span class="lineNum">    1314 </span>            :   int* index_i_out = matrix_out-&gt;index_i;
<span class="lineNum">    1315 </span>            :   for (int out_row = 0; out_row &lt; end_row - start_row + 1; ++out_row) {
<span class="lineNum">    1316 </span>            :     index_i_out[out_row] = edge_i_out[out_row + 1] - edge_i_out[out_row];
<span class="lineNum">    1317 </span>            :   }
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :   // Put matrix into consistent state
<span class="lineNum">    1320 </span>            :   matrix_out-&gt;get_row_edge();
<span class="lineNum">    1321 </span>            :   matrix_out-&gt;get_diag_pos();
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :   return matrix_out;
<span class="lineNum">    1324 </span>            : }
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1327 </span>            : int Spike&lt;T&gt;::get_max_column(TCSR&lt;T&gt;* matrix_in) {
<span class="lineNum">    1328 </span>            :    return  *std::max_element(
<span class="lineNum">    1329 </span>            :            &amp;matrix_in-&gt;index_j[0],
<span class="lineNum">    1330 </span>            :            &amp;matrix_in-&gt;index_j[matrix_in-&gt;n_nonzeros]);
<span class="lineNum">    1331 </span>            : }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1334 </span>            : bool Spike&lt;T&gt;::has_right_hand_side() {
<span class="lineNum">    1335 </span>            :    return (F != NULL);
<span class="lineNum">    1336 </span>            : }
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            : /** \brief Copy one Matrix into an other
<span class="lineNum">    1339 </span>            :  */
<span class="lineNum">    1340 </span>            : template&lt;typename T&gt;
<span class="lineNum">    1341 </span>            : void Spike&lt;T&gt;::merge_matrix_f(T* inout, int ldo, int start_row, 
<span class="lineNum">    1342 </span>            :                             int start_column, T* in, int size, int loi,
<span class="lineNum">    1343 </span>            :                             int length_column) {
<span class="lineNum">    1344 </span>            :     merge_matrix_c(inout, ldo, start_column, start_row, 
<span class="lineNum">    1345 </span>            :                               in, size, loi,
<span class="lineNum">    1346 </span>            :                              length_column);
<span class="lineNum">    1347 </span>            : }
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            : /** \brief Copy one Matrix into an other
<span class="lineNum">    1350 </span>            :  */
<span class="lineNum">    1351 </span>            : template&lt;typename T&gt;
<span class="lineNum">    1352 </span>            : void Spike&lt;T&gt;::merge_matrix_c(T* inout, int ldo, int start_row, 
<span class="lineNum">    1353 </span>            :                             int start_column, T* in, int size, int loi,
<span class="lineNum">    1354 </span>            :                             int length_column) {
<span class="lineNum">    1355 </span>            :   inout += start_row * ldo + start_column; // Go to position
<span class="lineNum">    1356 </span>            :   for (int i = 0, s = 0; s &lt; size ; i += loi, s += length_column) {
<span class="lineNum">    1357 </span>            :     // Copy consecutive column
<span class="lineNum">    1358 </span>            :     memcpy (&amp;inout[0], &amp;in[i], length_column * sizeof(T));
<span class="lineNum">    1359 </span>            :     // Jump to next row in inout matrix
<span class="lineNum">    1360 </span>            :     inout += ldo;    
<span class="lineNum">    1361 </span>            :   }   
<span class="lineNum">    1362 </span>            : }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            : /** \brief            Solves a linear system using sparse linear algebra
<span class="lineNum">    1366 </span>            :  *
<span class="lineNum">    1367 </span>            :  * \param[in]         M
<span class="lineNum">    1368 </span>            :  *                    Coefficient matrix in CSR format
<span class="lineNum">    1369 </span>            :  *
<span class="lineNum">    1370 </span>            :  * \param[in]         B
<span class="lineNum">    1371 </span>            :  *                    Right hand side of the equation.
<span class="lineNum">    1372 </span>            :  *
<span class="lineNum">    1373 </span>            :  * \param[in]         B_cols
<span class="lineNum">    1374 </span>            :  *                    Number of columns of B.
<span class="lineNum">    1375 </span>            :  *
<span class="lineNum">    1376 </span>            :  * \param[in|out]     X
<span class="lineNum">    1377 </span>            :  *                    The solution.
<span class="lineNum">    1378 </span>            :  */
<span class="lineNum">    1379 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1380 </span>            : void Spike&lt;T&gt;::solve_linear_system_sparse(TCSR&lt;T&gt;* Mat, T* B, int B_cols, T* X) {
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span>            :   // OMENdft
<span class="lineNum">    1383 </span>            :   Pardiso::sparse_solve(Mat, B, B_cols, X);
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :   // OMEN
<span class="lineNum">    1386 </span>            :   //LinearSolver&lt;CPX&gt; solver = new Pardiso(Mat, comm);
<span class="lineNum">    1387 </span>            :   //solver-&gt;prepare();
<span class="lineNum">    1388 </span>            :   //solver-&gt;solve_equation(X, B, B_cols);
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span>            : }
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            : /** \brief Get the value of the entry i,j of the sparse matrix
<span class="lineNum">    1394 </span>            :  *
<span class="lineNum">    1395 </span>            :  * \param[in]  Mat   The sparse matrix.
<span class="lineNum">    1396 </span>            :  *
<span class="lineNum">    1397 </span>            :  * \param[in]    i   row number.
<span class="lineNum">    1398 </span>            :  *
<span class="lineNum">    1399 </span>            :  * \param[in]    j   column number.
<span class="lineNum">    1400 </span>            :  *
<a name="1401"><span class="lineNum">    1401 </span>            :  */</a>
<span class="lineNum">    1402 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 : T Spike&lt;T&gt;::get_sparse_matrix_value(TCSR&lt;T&gt;* Mat, int i, int j) {</span>
<span class="lineNum">    1404 </span>            :    
<span class="lineNum">    1405 </span>            :   // loop up interval for col_indices
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :   int start = Mat-&gt;edge_i[i];</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   int end   = Mat-&gt;edge_i[i + 1];</span>
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            :   // serach j in col_indices
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   for (int g = start; g &lt; end; ++g) {</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     if (Mat-&gt;index_j[g] == j) { // if found return data form that pos</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :       return Mat-&gt;nnz[g];</span>
<span class="lineNum">    1413 </span>            :     }
<span class="lineNum">    1414 </span>            :   }
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :   return T(0, 0);</span>
<span class="lineNum">    1416 </span>            : }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : /** \brief            Transpose dense matrix (out of place)
<span class="lineNum">    1419 </span>            :  *
<span class="lineNum">    1420 </span>            :  *  \param[in|out]    matrix
<span class="lineNum">    1421 </span>            :  *                    The matrix to transpose / the transposed matrix.
<span class="lineNum">    1422 </span>            :  *
<span class="lineNum">    1423 </span>            :  *  \param[in]        rows
<span class="lineNum">    1424 </span>            :  *                    Number of rows of matrix before the call.
<span class="lineNum">    1425 </span>            :  *
<span class="lineNum">    1426 </span>            :  *  \param[in]        cols
<span class="lineNum">    1427 </span>            :  *                    Number of columns of matrix before the call.
<span class="lineNum">    1428 </span>            :  *
<span class="lineNum">    1429 </span>            :  */
<span class="lineNum">    1430 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1431 </span>            : void Spike&lt;T&gt;::transpose_dense_matrix(T* matrix, int rows, int cols) {
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :   int size = rows * cols; 
<span class="lineNum">    1434 </span>            :   T* temp = new T[size];
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            :   memcpy(temp, matrix, size * sizeof(T)); 
<span class="lineNum">    1437 </span>            :   
<span class="lineNum">    1438 </span>            :   trans(temp, matrix, rows, cols);
<span class="lineNum">    1439 </span>            :   
<span class="lineNum">    1440 </span>            :   delete[] temp;
<span class="lineNum">    1441 </span>            : }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            : /** \brief            Transposes a dense matrix src and writes the result into
<span class="lineNum">    1444 </span>            :  *                    dst
<span class="lineNum">    1445 </span>            :  *
<span class="lineNum">    1446 </span>            :  *  \param[in]        src
<span class="lineNum">    1447 </span>            :  *                    The matrix to be transposed.
<span class="lineNum">    1448 </span>            :  *
<span class="lineNum">    1449 </span>            :  *  \param[in]        dst
<span class="lineNum">    1450 </span>            :  *                    The matrix containing the transposed of src after the
<span class="lineNum">    1451 </span>            :  *                    function call.
<span class="lineNum">    1452 </span>            :  *
<span class="lineNum">    1453 </span>            :  *  \param[in]        rows
<span class="lineNum">    1454 </span>            :  *                    Number of row of src.
<span class="lineNum">    1455 </span>            :  *
<span class="lineNum">    1456 </span>            :  *  \param[in]        cols
<span class="lineNum">    1457 </span>            :  *                    Number of columns of src.
<span class="lineNum">    1458 </span>            :  */
<span class="lineNum">    1459 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1460 </span>            : void Spike&lt;T&gt;::trans(T* src, T* dst, const int rows, const int cols) {
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            :   #pragma omp parallel for
<span class="lineNum">    1463 </span>            :   for (int n = 0; n &lt; rows * cols; ++n) {
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            :     int i  = n / rows;
<span class="lineNum">    1466 </span>            :     int j  = n % rows;
<span class="lineNum">    1467 </span>            :     dst[n] = src[cols * j + i];
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :   }
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            : }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : #ifdef SPIKE_DEBUG
<span class="lineNum">    1475 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1476 </span>            : void Spike&lt;T&gt;::dump(TCSR&lt;T&gt;* matrix, const char* prefix) {
<span class="lineNum">    1477 </span>            :   std::cout &lt;&lt; &quot;rank &quot; &lt;&lt; rank &lt;&lt; &quot;: dumping &quot; &lt;&lt; prefix &lt;&lt; &quot;\n&quot;;
<span class="lineNum">    1478 </span>            :   stringstream filename;
<span class="lineNum">    1479 </span>            :   filename &lt;&lt; debug_path &lt;&lt; prefix &lt;&lt; &quot;_rank&quot; &lt;&lt; rank &lt;&lt; &quot;.csv&quot;;
<span class="lineNum">    1480 </span>            :   matrix-&gt;write(filename.str().c_str());
<span class="lineNum">    1481 </span>            : };
<span class="lineNum">    1482 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1483 </span>            : void Spike&lt;T&gt;::dump_c(T* matrix, int rows, int cols, const char* prefix) {
<span class="lineNum">    1484 </span>            :   std::cout &lt;&lt; &quot;rank &quot; &lt;&lt; rank &lt;&lt; &quot;: dumping &quot; &lt;&lt; prefix &lt;&lt; &quot;\n&quot;;
<span class="lineNum">    1485 </span>            :   stringstream filename;
<span class="lineNum">    1486 </span>            :   filename &lt;&lt; debug_path &lt;&lt; prefix &lt;&lt; &quot;_rank&quot; &lt;&lt; rank &lt;&lt; &quot;.csv&quot;;
<span class="lineNum">    1487 </span>            :   write_mat_c(matrix, rows, cols, filename.str().c_str());
<span class="lineNum">    1488 </span>            : };
<span class="lineNum">    1489 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1490 </span>            : void Spike&lt;T&gt;::dump_f(T* matrix, int rows, int cols, const char* prefix) {
<span class="lineNum">    1491 </span>            :   std::cout &lt;&lt; &quot;rank &quot; &lt;&lt; rank &lt;&lt; &quot;: dumping &quot; &lt;&lt; prefix &lt;&lt; &quot;\n&quot;;
<span class="lineNum">    1492 </span>            :   stringstream filename;
<span class="lineNum">    1493 </span>            :   filename &lt;&lt; debug_path &lt;&lt; prefix &lt;&lt; &quot;_rank&quot; &lt;&lt; rank &lt;&lt; &quot;.csv&quot;;
<span class="lineNum">    1494 </span>            :   write_mat_f(matrix, rows, cols, filename.str().c_str());
<span class="lineNum">    1495 </span>            : };
<span class="lineNum">    1496 </span>            : #else
<span class="lineNum">    1497 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1498 </span>            : void Spike&lt;T&gt;::dump(TCSR&lt;T&gt;* matrix, const char* prefix) {};
<span class="lineNum">    1499 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1500 </span>            : void Spike&lt;T&gt;::dump_c(T* matrix, int rows, int cols, const char* prefix) {};
<span class="lineNum">    1501 </span>            : template &lt;typename T&gt;
<span class="lineNum">    1502 </span>            : void Spike&lt;T&gt;::dump_f(T* matrix, int rows, int cols, const char* prefix) {};
<span class="lineNum">    1503 </span>            : #endif /* SPIKE_DEBUG */
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
